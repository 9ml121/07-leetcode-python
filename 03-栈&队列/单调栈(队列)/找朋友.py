""" 
https://fcqian.blog.csdn.net/article/details/127342018

题目描述
在学校中，N个小朋友站成一队， 第i个小朋友的身高为height[i]，
第i个小朋友可以看到的第一个比自己身高更高的小朋友j，那么j是i的好朋友(要求j > i)。
请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。
小朋友人数范围是 [0, 40000]。

输入描述
第一行输入N，N表示有N个小朋友

第二行输入N个小朋友的身高height[i]，都是整数

输出描述
输出N个小朋友的好朋友的位置

用例
输入	
2
100 95
输出	
0 0
说明	
第一个小朋友身高100，站在队尾位置，向队首看，没有比他身高高的小朋友，所以输出第一个值为0。
第二个小朋友站在队首，前面也没有比他身高高的小朋友，所以输出第二个值为0。

输入	
8
123 124 125 121 119 122 126 123
输出	1 2 6 5 5 6 0 0
说明	123的好朋友是1位置上的124
124的好朋友是2位置上的125
125的好朋友是6位置上的126
以此类推
"""

# 类似：04-栈&队列/栈/单调栈/496-下一个更大的元素.py
# 双重for循环会超时，采用倒序遍历，单调栈存储前面人从高到低的索引，可以一次遍历完成

# 输入：
n = int(input())
# N个小朋友的身高
nums = list(map(int, input().split()))

# 输出N个小朋友的好朋友的位置
ans = [0] * n
st = []  # 单调递减，保存的是数组索引(保存值也可以)
# 倒序遍历：队首的人前面没有人，输出0，从倒数第二个开始遍历
for i in range(n-2, -1, -1):
    x = nums[i]
    while st and x >= nums[st[-1]]:
        st.pop()

    if st:
        ans[i] = st[-1]
        
    st.append(i)

print(' '.join(map(str, ans)))
