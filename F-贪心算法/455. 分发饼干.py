"""
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。
如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。


示例 1:
输入: g = [1,2,3], s = [1,1]
输出: 1
解释:
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

示例 2:
输入: g = [1,2], s = [1,2,3]
输出: 2
解释:
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.


提示：
1 <= g.length <= 3 * 10^4
0 <= s.length <= 3 * 10^4
1 <= g[i], s[j] <= 2^31 - 1
"""
from typing import List

"""
「贪心算法」的直觉 1：
1.如果最小的饼干都不能满足胃口最小的小朋友，那么这块最小的饼干一定也不能满足比他（她）还贪心的小朋友。此时我们舍弃这块饼干。
2.因此当前问题贪心的点是：如果一个小朋友的胃口大小是 a ，我们在分配饼干的时候，给能他（她）大小为 a 的饼干，绝对不会给大小为 a + 1 的饼干

因此「贪心算法」应用在这个问题里，是一种「吝啬」的策略。
"""


class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        # 胃口值 g[i],饼干尺寸s[i], 用最小的饼干去满足贪心程度最低的小朋友
        s.sort()
        g.sort()

        si, gi = 0, 0
        while si < len(s) and gi < len(g):
            if s[si] >= g[gi]:
                gi += 1
            si += 1
        return gi


"""
「直觉 1」的「吝啬」的策略相比，我们还可以想出一种「大方」的策略。
「贪心算法」的直觉 2：
给最贪心的小朋友最大的饼干。如果最大的这块饼干都不能满足最贪心的小朋友，此时我们需要放弃最贪心的小朋友，进而考虑次贪心的小朋友。
"""


class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        # 胃口值 g[i],饼干尺寸s[i],用最大的饼干去满足贪心程度最大的小朋友
        s.sort()
        g.sort()
        ans = 0

        si, gi = len(s) - 1, len(g) - 1
        while si >= 0 and gi >= 0:
            if s[si] >= g[gi]:
                ans += 1
                si -= 1
            gi -= 1
            
        return ans
