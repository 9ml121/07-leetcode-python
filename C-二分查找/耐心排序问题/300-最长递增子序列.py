"""
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4

示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1


提示：
1 <= nums.n <= 2500
-104 <= nums[i] <= 104


进阶：
你能将算法的时间复杂度降低到 O(n log(n)) 吗?
"""
from typing import List


# todo 方法1：动态规划 O(n^2)
def lengthOfLIS(nums: List[int]) -> int:
    # 跟最长 连续 递增子序列不是同一个问题，双指针肯定不行
    # 动态规划：
    n = len(nums)
    dp = [1] * n  # todo dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。默认值为1
    for i in range(1, n):  # 从第二个数开始
        for j in range(i):  # 查找索引前面比他小的数，然后统计“严格递增”长度最大的
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    print(dp)
    return max(dp)
    # nums =[10, 9, 2, 5, 3, 7, 101, 18].  [1, 3, 6, 7, 9, 4, 10, 5, 6]
    # dp   =[1,  1, 1, 2, 2, 3, 4,   4].   [1, 2, 3, 4, 5, 3, 6,  4, 5]


# todo 方法2：单调栈(错误解法！！)： nums = [0,1,0,3,2,3]  第二个0会把前面的01给顶掉
def lengthOfLIS2(nums: List[int]) -> int:
    # todo 用一个单调栈来记录每次遍历过的数字最优递增序列组合
    # 比如 253， 最优的是23，因为后面比5大的，一定比3大
    stack = []
    n = len(nums)
    maxL = 1
    for i in range(1, n):
        val = nums[i]
        while stack and stack[-1] >= val:
            stack.pop()

        stack.append(val)
        maxL = max(maxL, len(stack))
    # print(stack)
    return maxL


# todo 方法3：耐心排序 ==> 过渡到方法4的
'''
参考：https://blog.csdn.net/qfc_128220/article/details/127931755
https://labuladong.gitee.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-6ea57/
我们可以发现nums = [10,9,2]这个子问题的有三个递增子序列，分别是10子序列、9子序列以及2子序列。
那么这三个子序列哪个是最优的呢？
所谓最优，即当我为nums = [10,9,2]追加一个数据，那么上面三个子序列哪个是最有可能和追加的数组合在一起，形成一个长度为2的递增子序列呢？
答案是2子序列，因为2 < 9 < 10，如果追加的数可以和9或10组合形成递增子序列，那么一定可以和2组合形成递增子序列。
因此2子序列是是长度为1的最优子序列。
接下来再追加一个数据3，nums = [10,9,2,5,3]
那么哪个子序列是长度为2的最优子序列呢？
首先长度为2的子序列已经有了一个2 5，当追加一个数据3进来后，发现2 3形成的长度为2子序列的子序列更优。因此此时长度为2的最优子序列是2 3。

nums = [10,9,2,5,3,7,101,18]
按照此逻辑，我们可以求得

长度为1的最优子序列为2
长度为2的最优子序列为2 3
长度为3的最优子序列为2 3 7
长度为4的最优子序列为2 3 7 18
其实最优子序列的特性是由子序列的最后一位绝对的，而前面的数据无关，因此我们可以将上面总结改为：

长度为1的最优子序列的尾数为2
长度为2的最优子序列的尾数为3
长度为3的最优子序列的尾数为7
长度为4的最优子序列的尾数为18
我们可以重新定义dp数组，dp[i]的含义就是长度为i+1的最优子序列的尾数值。

因此dp数组的长度即为最长递增子序列的长度。

如果大家对于上面逻辑还是不懂，这里还有一个生动的例子可以帮助理解：
即有一组牌 [10,9,2,5,3,7,101,18] ，可以分为多组，但是每组的下面的牌必须比上面的牌大，因此分牌过程如下
...
可以发现一共分成了4组，而这就是我们需要求得递增子序列的最长长度。
而这个分牌逻辑其实就是耐心排序，耐心排序同样适用于前面求每个固定长度下，最优子序列的尾数的逻辑
'''


def lengthOfLIS3(nums):
    dp = [nums[0]]

    for i in range(1, len(nums)):
        if nums[i] > dp[-1]:
            dp.append(nums[i])
            continue

        for j in range(len(dp)):
            if nums[i] <= dp[j]:
                dp[j] = nums[i]
                break

    return len(dp)


# todo 方法4：动态规划 + B-二分查找  O(NlogN) 最优解，但是不好理解
# Dynamic programming + Dichotomy.
'''
直接看文字确实不太好懂，加个例子就比较容易明白，
比如序列是78912345，前三个遍历完以后tail是789，
这时候遍历到1，就得把1放到合适的位置，
于是在tail二分查找1的位置，变成了189（如果序列在此时结束，因为res不变，所以依旧输出3），
再遍历到2成为129，然后是123直到12345 

这题难理解的核心不在于算法难，而在于在于官方给的例子太拉了，遇不到这个算法真正要解决的问题，
即没有我例子中1要代替7的过程，官例中每次替代都是替代tail的最后一个数 老哥比官解讲的好太多了，点个赞
'''


def lengthOfLIS4(nums: [int]) -> int:
    # tails[i]的含义就是长度为i+1的最优子序列的尾数值。
    tails = [0] * len(nums)
    res = 0  # 代表牌堆数量，初始化为0，

    for num in nums:  # num代表要处理的扑克牌
        left = 0
        right = res
        # 搜索左侧边界的二分查找：查找tails第一个比num大的数
        while left < right:  # 左闭右开区间，搜索
            mid = (left + right) // 2
            if tails[mid] < num:
                left = mid + 1  # 如果要求非严格递增，将此行 '<' 改为 '<=' 即可。
            elif tails[mid] >= num:
                right = mid

        # 没找到合适的牌堆，新建一堆: 左边的牌都比目标值小
        if left == res:
            res += 1
        # 把这张牌放到牌堆顶
        tails[left] = num
    # 牌堆数就是LIS长度
    print(tails)
    return res


if __name__ == '__main__':
    # nums = [10, 9, 2, 5, 3, 7, 101, 18]
    nums = [7, 8, 9, 1, 2, 3, 4, 5]
    print(lengthOfLIS4(nums))
