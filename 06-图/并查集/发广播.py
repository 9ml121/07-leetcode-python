"""
题目描述
某地有N个广播站，站点之间有些有连接，有些没有。有连接的站点在接受到广播后会互相发送。
给定一个N*N的二维数组matrix,数组的元素都是字符’0’或者’1’。
matrix[i][j] = ‘1’, 代表i和j站点之间有连接，
matrix[i][j] = ‘0’, 代表没连接，

现在要发一条广播，问初始最少给几个广播站发送，才能保证所有的广播站都收到消息。

输入描述
从stdin输入，共一行数据，表示二维数组的各行，用逗号分隔行。保证每行字符串所含的字符数一样的。
比如：110,110,001。

输出描述
返回初始最少需要发送广播站个数

用例
输入	110,110,001
输出	2
说明	站点1和站点2直接有连接，站点3和其他的都没连接，所以开始至少需要给两个站点发送广播。

输入	100,010,001
输出	3
说明	3台服务器互不连接，所以需要分别广播这3台服务器。

输入	11,11
输出	1
说明	2台服务器相互连接，所以只需要广播其中一台服务器
"""

'''
题目解析
1. 最多要给n个站点发
2。最少要给1个站点发
3。如果有站点和站点相连，就生成了一条条站点互联的链路数，问题就是要找有多少条不相连的链路？


方法2：并查集.md
题目中说：“有连接的站点在接受到广播后会互相发送。”
这表明了如果matrix[i][j] = ‘1’,则必然matrix[j][i] = ‘1’，即如下图中二维矩阵中元素值，会沿左上右下对角线轴对称
解决本题，我们只需要看对角线的一侧即可。 

那么如何才能构建上面这种连通图呢？
最好的方式就是创建 并查集.md 结构。
并查集本身其实就是一个数组，数组的索引指代站点，数组的元素值指代当前索引站点的祖先站点。
'''

# 1,获取输入
# matrix = input().split(',')
# print(matrix)
# matrix = ['110', '110', '001']
# matrix = ['1101', '1100', '0011', '1011']
matrix = ['11010', '11000', '00110', '10110', '00001']


# [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
# [[1, 1, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1], [1, 0, 1, 1]]
# [[1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 0], [1, 0, 1, 1, 0], [0, 0, 0, 0, 1]]
# todo 并查集实现
class UnionFindSet:
    def __init__(self, n):
        self.fa = [i for i in range(n)]  # 0-n各个索引对应的父节点，初始化是索引本身
        self.count = n  # 联通分量

    def find(self, x):
        if x != self.fa[x]:
            # 完全压缩
            self.fa[x] = self.find(self.fa[x])

        return self.fa[x]

    def union(self, x, y):  # 3。更新坐标的父节点
        x_fa = self.find(x)
        y_fa = self.find(y)

        if x_fa != y_fa:
            self.fa[y_fa] = x_fa  # (0, 1):将1的父节点改为0
            self.count -= 1  # count记录没有更新过父节点的数量


# 算法入口
def getResult(matrix):
    n = len(matrix)
    ufs = UnionFindSet(n)

    # 遍历输入的二维数组对角线一侧的站点连接情况，来更新上面的并查集结构
    for i in range(n):
        for j in range(i + 1, n):
            if matrix[i][j] == "1":
                ufs.union(i, j)

    return ufs.count  # count是没有更新过父节点的数量，就是坐标数组最终形成的链路数


# 算法调用
print(getResult(matrix))
