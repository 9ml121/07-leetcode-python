"""
题目解析和算法源码
https://fcqian.blog.csdn.net/article/details/135268635?spm=1001.2014.3001.5502

OJ用例
题解 - 伐木工 - Hydro

题目描述
一根X米长的树木，伐木工切割成不同长度的木材后进行交易，交易价格为每根木头长度的乘积。规定切割后的每根木头长度都为正整数；也可以不切割，直接拿整根树木进行交易。

请问伐木工如何尽量少的切割，才能使收益最大化？

输入描述
木材的长度（X ≤ 50）

输出描述
输出最优收益时的各个树木长度，以空格分隔，按升序排列

用例1
输入
10
输出
3 3 4
说明
一根2米长的树木，伐木工不切割，为2 * 1，收益最大为2

一根4米长的树木，伐木工不需要切割为2 * 2，省去切割成本，直接整根树木交易，为4 * 1，收益最大为4

一根5米长的树木，伐木工切割为2 * 3，收益最大为6

一根10米长的树木，伐木工可以切割方式一：3，4，4，也可以切割为方式二：3，2，2，3，但方式二伐木工多切割一次，增加切割成本却买了一样的价格，因此并不是最优收益。
"""


# 输入：木材长度 X ≤ 50
x = int(input())

# 输出：最优收益时的各个树木长度，以空格分隔，按升序排列（相同收益时要求切割次数最少）


def main():
    # dp[i]代表木材长度为i时，最优收益时的各个树木长度
    # dp[i]是一个两位数组(dp[i][0]是最大收益，dp[i][1]是切割树木长度数组)
    dp = [[] for _ in range(x+1)]

    for i in range(x+1):
        # 1.木材长度在4以内，收益最大都是为不切割
        if i <= 4:
            dp[i] = [i, [i]]
            continue

        max_v = i  # 切割最大收益
        min_sz = 1  # 切割次数
        for j in range(2, i//2 + 1):
            v = dp[j][0] * dp[i-j][0]
            sz = len(dp[j][1]) + len(dp[i-j][1])
            if v > max_v or (v == max_v and sz < min_sz):
                max_v = v
                min_sz = sz
                dp[i] = [max_v, dp[j][1] + dp[i-j][1]]

    # print(dp)
    ans = dp[-1][1]
    ans.sort()
    return ' '.join(map(str, ans))


print(main())
