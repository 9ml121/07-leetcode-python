"""
有一根长度为 n 个单位的木棍，棍上从 0 到 n 标记了若干位置。例如，长度为 6 的棍子可以标记如下：

给你一个整数数组 cuts ，其中 cuts[i] 表示你需要将棍子切开的位置。
你可以按顺序完成切割，也可以根据需要更改切割的顺序。
每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。
对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。
请参阅第一个示例以获得更直观的解释。

返回切棍子的 最小总成本 。

示例 1：
输入：n = 7, cuts = [1,3,4,5]
输出：16
解释：按 [1, 3, 4, 5] 的顺序切割的情况如下所示：
第一次切割长度为 7 的棍子，成本为 7 。
第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），
第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。
总成本为 7 + 6 + 4 + 3 = 20 。
而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。

示例 2：
输入：n = 9, cuts = [5,6,1,4,2]
输出：22
解释：如果按给定的顺序切割，则总成本为 25 。
总成本 <= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。


提示：
2 <= n <= 10^6
1 <= cuts.length <= min(n - 1, 100)
1 <= cuts[i] <= n - 1
cuts 数组中的所有整数都 互不相同
"""
from typing import List

"""
本题和 312. 戳气球 较为相似，都是经典的区间动态规划题。

题目描述：
给定一个整数数组 cuts 表示要切割的位置，初始时整个棍子的长度为 n。
切割棍子的成本为当前棍子的长度。
要求按照 cuts 数组中的位置顺序依次进行切割，计算切割棍子的最小成本。

解题思路：
这是一个动态规划的问题，可以使用动态规划的思想来解决。下面给出该问题的动态规划解法的思路：
1.将 cuts 数组的长度加2，并将其首尾分别添加为0和n，得到新的数组 points，表示切割点的位置。
2.创建一个二维数组 dp，其中 dp[i][j] 表示从位置 i 到位置 j 的子区间切割的最小成本。
3.使用动态规划的思想，从最小的子问题开始，逐步增加问题的规模，直到解决整个问题。
4.对于任意的子问题 dp[i][j]，我们可以遍历区间内的所有分割点 k，将区间 [i, j] 分割为两部分 [i, k] 和 [k, j]。
  切割的成本为当前子区间的长度 points[j] - points[i]，加上左右两个子区间的最小成本，
  即 dp[i][j] = points[j] - points[i] + min(dp[i][k] + dp[k][j] for k in range(i+1, j))。
5.遍历顺序为从子区间的长度为2开始，逐步增加长度，直到遍历整个区间。
6.最终，dp[0][len(points)-1] 即为切割整个棍子的最小成本。

知识点：
动态规划 设 dp[L][R] 为切割以L，R为左右端点的木棍的最小成本。
显然 L，R 的取值只能是 0，n，或者 cuts中的某个数。 
如果不存在 i 满足 L < cuts[i] < R，那么dp[L][R] = 0，因为根本不用切了。 
如果存在 i 满足上述条件，则 dp[L][R] = min(dp[L][cuts[i]] + dp[cuts[i]][R]) + R-L。
"""


class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        new_cuts = [0] + sorted(cuts) + [n]
        m = len(new_cuts)
        # 1.dp[i][j] 表示从位置 i 到位置 j 的子区间切割的最小成本。
        # dp[0][m-1] 即为切割整个棍子的最小成本。
        dp = [[0] * m for _ in range(m)]

        # 遍历顺序为从子区间的长度为2开始，逐步增加长度，直到遍历整个区间
        # 根据题意，如果子区间长度为1，比如[1,2],这个区间是无法进行切割的，即dp[i][j] = 0 if j == i+1
        # cuts = [0] + [1,3,4,5] + [7]
        for gap in range(2, m):
            for i in range(m - gap):  # j = i+gap < m 计算出 i < m -gap
                j = i + gap
                dp[i][j] = float('inf')
                for k in range(i + 1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
                dp[i][j] += new_cuts[j] - new_cuts[i]
                
        return dp[0][m - 1]


if __name__ == '__main__':
    n = 9
    cuts = [5, 6, 1, 4, 2]
    print(Solution().minCost(n, cuts))
