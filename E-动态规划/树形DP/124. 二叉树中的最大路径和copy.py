"""
二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。
该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：
       1
      / \
     2   3

输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6

示例 2：
   -10
   / \
  9  20
    /  \
   15   7

输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42


提示：
树中节点数目范围是 [1, 3 * 104]
-1000 <= Node.value <= 1000
"""
from myTreeNode2 import *

"""
问题描述：
给定一个非空二叉树，返回路径和最大的路径。
路径被定义为从树中任意节点出发，沿着父节点-子节点连接，达到任意节点的序列。
路径和是路径中各节点值的总和。

解题思路：
这个问题可以使用递归来解决。对于二叉树中的每个节点，我们可以考虑以下情况：
1.最大路径和经过该节点的情况：
  对于当前节点 node，最大路径和可能是 node.val 加上其左子树的最大路径和（如果大于零），再加上其右子树的最大路径和（如果大于零）。
2.最大路径和不经过该节点的情况：
  对于当前节点 node，最大路径和可能是其左子树的最大路径和或者右子树的最大路径和，取其中较大的一个。
3.因此，我们可以定义一个递归函数 maxPathSum(node)，它返回以 node 为根节点的子树中的最大路径和。
  在递归函数中，我们首先处理递归的终止条件，即节点为空时，返回 0。
  然后，我们分别计算经过当前节点和不经过当前节点的情况下的最大路径和，并取其中的较大值作为结果。

4.为了避免重复计算，我们可以使用一个全局变量 max_sum 来存储最大路径和。
  在递归函数中，我们更新 max_sum 的值，每次都取当前节点的最大路径和与 max_sum 的较大值。
"""


class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        """返回二叉树中的最大路径和"""
        max_sum = float('-inf')

        def dfs(node) -> int:
            """递归函数，返回当前节点的最大贡献值"""
            nonlocal max_sum
            if not node:
                return 0
            # 递归计算左右子节点的最大贡献值
            # 只有在最大贡献值大于 0 时，才会选取对应子节点
            # 注意 1：后序遍历 + 剪枝，把从下到上路径和为 0 的枝叶剪去
            left_max = max(0, dfs(node.left))
            right_max = max(0, dfs(node.right))

            # 更新最大路径和
            # 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
            current_max = left_max + right_max + node.val
            max_sum = max(max_sum, current_max)

            # 返回当前节点的最大贡献值
            # 注意 2：这里是 dp 的思想（无后效性），node.val 必须被选取，且左右路径只选一条
            return max(left_max, right_max) + node.val

        # 调用递归函数，返回最大路径和
        dfs(root)
        return max_sum


if __name__ == '__main__':
    arr = [5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, 1]
