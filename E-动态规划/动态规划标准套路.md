> https://labuladong.gitee.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--28f3c/
# 动规标准套路

## 第一步要明确两点，「状态」和「选择」。
先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀.
所以状态有两个，就是「背包的容量」和「可选择的物品」。

再说选择，也很容易想到啊，对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」嘛。
明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：
```
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)

```

## 第二步要明确 dp 数组的定义。
首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 dp 数组。
dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

根据这个定义，我们想求的最终答案就是 dp[N][W]。

base case 就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

细化上面的框架：
```
int[][] dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            把物品 i 装进背包,
            不把物品 i 装进背包
        )
return dp[N][W]

```
## 第三步，根据「选择」，思考状态转移的逻辑。
简单说就是，上面伪码中「把物品 i 装进背包」和「不把物品 i 装进背包」怎么用代码体现出来呢？
这就要结合对 dp 数组的定义，看看这两种选择会对状态产生什么影响：
先重申一下刚才我们的 dp 数组的定义：
dp[i][w] 表示：对于前 i 个物品（从 1 开始计数），当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]。
- **如果你没有把这第 i 个物品装入背包**，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。
- **如果你把这第 i 个物品装入了背包**，那么 dp[i][w] 应该等于 val[i-1] + dp[i-1][w - wt[i-1]]。

**首先，由于数组索引从 0 开始，而我们定义中的 i 是从 1 开始计数的，所以 val[i-1] 和 wt[i-1] 表示第 i 个物品的价值和重量。**

你如果选择将第 i 个物品装进背包，那么第 i 个物品的价值 val[i-1] 肯定就到手了，
接下来你就要在剩余容量 w - wt[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值，即 dp[i-1][w - wt[i-1]]。

综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：
```
for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            dp[i-1][w],
            dp[i-1][w - wt[i-1]] + val[i-1]
        )
return dp[N][W]

```
## 最后一步，把伪码翻译成代码，处理一些边界情况。
我用 Java 写的代码，把上面的思路完全翻译了一遍，并且处理了 w - wt[i-1] 可能小于 0 导致数组索引越界的问题：
```python
from typing import List

def knapsack(W: int, N: int, wt: List[int], val: List[int]) -> int:
    assert N == len(wt)
    # 初始化一个二维数组，用于存储状态
    # dp[i][j] 表示将前 i 个物品装入容量为 j 的背包中所获得的最大价值
    dp = [[0] * (W + 1) for _ in range(N + 1)]
    # 开始进行递推
    for i in range(1, N + 1):
        for w in range(1, W + 1):
            if w - wt[i - 1] < 0:
                # 当前商品 i 的重量已经超过了 w，无法被放入当前容量为 w 的背包中，只能选择不装入背包
                dp[i][w] = dp[i - 1][w]
            else:
                # 当前商品 i 的重量小于等于当前容量 w，可以尝试将其放入背包中
                # 取最大值，考虑是将其放入之前的最优方案中还是选择不放
                dp[i][w] = max(
                    dp[i - 1][w - wt[i - 1]] + val[i - 1],
                    dp[i - 1][w]
                )
    # 返回最大价值
    return dp[N][W]

```
其实函数签名中的物品数量 N 就是 wt 数组的长度，所以实际上这个参数 N 是多此一举的。但为了体现原汁原味的 0-1 背包问题，我就带上这个参数 N 了，你自己写的话可以省略。

# 01背包和完全背包的区别
有一个背包，最大容量为 amount，有一系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量无限。
请问有多少种方法，能够把背包恰好装满？

这个问题和我们前面讲过的两个背包问题，有一个最大的区别就是，**每个物品的数量是无限的**，这也就是传说中的「完全背包问题」，
没啥高大上的，无非就是状态转移方程有一点变化而已。

# 空间压缩技巧
能够使用空间压缩技巧的动态规划都是二维 dp 问题，你看它的状态转移方程，
如果计算状态 dp[i][j] 需要的都是 dp[i][j] 相邻的状态，那么就可以使用空间压缩技巧，
将二维的 dp 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。

# 子序列问题解题模板
子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举你都不一定会，更别说求解相关的算法问题了。
而且，子序列问题很可能涉及到两个字符串，比如前文 最长公共子序列，如果没有一定的处理经验，真的不容易想出来。
所以本文就来扒一扒子序列问题的套路，其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。

一般来说，这类问题都是让你求一个最长子序列，因为最短子序列就是一个字符嘛，没啥可问的。
一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)。**

原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着？
既然要用动态规划，那就要定义 dp 数组，找状态转移关系 。
我们说的两种思路模板，就是 dp 数组的定义思路。
不同的问题可能需要不同的 dp 数组定义来解决。

一、两种思路
## 1、第一种思路模板是一个一维的 dp 数组：
```
n = len(nums)
dp = [0] * n
for i in range(1, n):
    for j in range(i):
        if ...:
           dp[i] = max(dp[j] + 1, dp[i]) 

```
比如我们写过的 最长递增子序列 和 最大子数组和 都是这个思路。
在这个思路中 dp 数组的定义是：
在子数组 arr[0..i] 中，以 arr[i] 结尾的子序列的长度是 dp[i]。
为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。

## 2、第二种思路模板是一个二维的 dp 数组：
```
n1, n2 = len(nums1), len(nums2);
dp = [[0] * (n2+1) for _ in range(n1+1)

for i in range(1, n1+1):
    for j in range(1, n2 + 1):
        if (arr[i] == arr[j]) 
            dp[i][j] = dp[i][j] + ...
        else
            dp[i][j] = 最值(...)

```
这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列时，比如前文讲的 最长公共子序列 和 编辑距离；
这种思路也可以用于只涉及一个字符串/数组的情景，比如本文讲的回文子序列问题。
