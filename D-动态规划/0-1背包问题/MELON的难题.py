"""
题目解析和算法源码
https://blog.csdn.net/qfc_128220/article/details/131476575

题目描述
MELON有一堆精美的雨花石（数量为n，重量各异），准备送给S和W。MELON希望送给俩人的雨花石重量一致，请你设计一个程序，帮MELON确认是否能将雨花石平均分配。

输入描述
第1行输入为雨花石个数：n， 0 < n < 31。

第2行输入为空格分割的各雨花石重量：m[0] m[1] ….. m[n - 1]， 0 < m[k] < 1001。

不需要考虑异常输入的情况。

输出描述
如果可以均分，从当前雨花石中最少拿出几块，可以使两堆的重量相等；如果不能均分，则输出-1。

用例1
输入
4
1 1 2 2
输出
2
说明
输入第一行代表共4颗雨花石，

第二行代表4颗雨花石重量分别为1、1、2、2。

均分时只能分别为1,2，需要拿出重量为1和2的两块雨花石，所以输出2

用例2
输入
10
1 1 1 1 1 9 8 3 7 10
输出
3
说明
输入第一行代表共10颗雨花石，

第二行代表4颗雨花石重量分别为1、1、1、1、1、9、8、3、7、10 。

均分时可以1,1,1,1,1,9,7和10,8,3，也可以1,1,1,1,9,8和10,7,3,1，或者其他均分方式，但第一种只需要拿出重量为10,8,3的3块雨花石，第二种需要拿出4块，所以输出3(块数最少)。
"""

# todo D-动态规划/0-1背包问题/416.分割等和子集.py 的变种题

# 输入
# 雨花石个数n
n = int(input())
# 各雨花石重量
weights = list(map(int, input().split()))
# print(weights)

# 输出：要求正好均分2份，需要最少拿出几块石头


def main():
    total = sum(weights)
    # 不能均分
    if total % 2 == 1:
        return -1

    # 有可能可以均分
    w = total // 2
    weights.sort()
    if weights[-1] > w:
        return -1

    # 将背包装满w，能够正好装满的最少物品数量
    # dp[i][j]表示从weights前i个物品中，正好装满重量为j需要选择的最少物品数
    dp = [[0] * (w+1) for _ in range(n+1)]
    # 第一行初始化为n,表示不可能正好装满背包的一个数字
    for j in range(w+1):
        dp[0][j] = n
    dp[0][0] = 0

    # 先将物品一一取出来
    for i in range(1, n+1):
        # 当前物品重量
        num = weights[i-1]
        # 背包容量从1到w
        for j in range(1, w+1):
            # 1.选择不装当前物品
            dp[i][j] = dp[i-1][j]
            # 2.选择装当前物品
            if num <= j:
                dp[i][j] = min(dp[i][j], dp[i-1][j-num] + 1)

    # print(dp)
    if dp[n][w] == n:
        return -1
    else:
        return min(dp[n][w], n - dp[n][w])


print(main())
