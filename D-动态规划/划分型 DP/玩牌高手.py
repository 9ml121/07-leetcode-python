"""
题目描述
给定一个长度为n的整型数组，表示一个选手在n轮内可选择的牌面分数。选手基于规则选牌，

请计算所有轮结束后其可以获得的最高总分数。

选择规则如下：
在每轮里选手可以选择获取该轮牌面，则其总分数加上该轮牌面分数，为其新的总分数。
选手也可不选择本轮牌面直接跳到下一轮，此时将当前总分数还原为3轮前的总分数，若当前轮次小于等于3（即在第1、2、3轮选择跳过轮次），则总分数置为0。
选手的初始总分数为0，且必须依次参加每一轮。

输入描述
第一行为一个小写逗号分割的字符串，表示n轮的牌面分数，1<= n <=20。

分数值为整数，-100 <= 分数值 <= 100。

不考虑格式问题。

输出描述
所有轮结束后选手获得的最高总分数。

用例
输入	1,-5,-6,4,3,6,-2
输出	11
说明	无
"""
# todo 动态规划

# 输入: 第一行为一个小写逗号分割的字符串，表示n轮的牌面分数
scores = list(map(int, input().split(',')))

# 输出：计算所有轮结束后其可以获得的最高总分数
n = len(scores)
# dp[i]代表scores第i个位置可以获得的最大分数
dp = [0] * n
# 初始化: 第一张牌可以选，也可以不选
dp[0] = max(0, scores[0])

# 状态推导
for i in range(1, n):
    if i <= 2:
        # 若当前轮次小于等于3（即在第1、2、3轮选择跳过轮次），则总分数置为0
        dp[i] = max(dp[i-1] + scores[i], 0)
    else:
        # 不选择本轮牌面直接跳到下一轮，此时将当前总分数还原为3轮前的总分数
        dp[i] = max(dp[i-3], dp[i-1] + scores[i])

# print(dp)
print(dp[-1])
