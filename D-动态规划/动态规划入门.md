> 参考 https://labuladong.gitee.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-1e688/
# 计算斐波那契数列
## 1.递归时间复杂度
递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。
显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。
算法低效的原因：存在大量重复计算

这就是动态规划问题的第一个性质：**重叠子问题**

## 2、带备忘录的递归解法
明确了问题，其实就已经把问题解决了一半。
即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；
每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

## 3、dp 数组的迭代（递推）解法: 状态转移方程式
为啥叫「状态转移方程」？其实就是为了听起来高端。
f(n) 的函数参数会不断变化，所以你把参数 n 想做一个状态，这个状态 n 是由状态 n - 1 和状态 n - 2 转移（相加）而来，这就叫**状态转移**，仅此而已。
你会发现，上面的几种解法中的所有操作， 例如 return f(n - 1) + f(n - 2)， dp[i] = dp[i - 1] + dp[i - 2]，
以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。

可见列出「状态转移方程」的重要性，它是解决问题的核心，而且很容易发现，其实状态转移方程直接代表着暴力解法。
这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：

## 4、空间复杂度优化
根据斐波那契数列的状态转移方程，当前状态 n 只和之前的 n-1, n-2 两个状态有关，
其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。
所以，可以进一步优化，把空间复杂度降为 O(1)。
```python
def fib(n: int) -> int:
    if n == 0 or n == 1:
        # base case
        return n
    # 分别代表 dp[i - 1] 和 dp[i - 2]
    dp_i_1, dp_i_2 = 1, 0
    for i in range(2, n + 1):
        # dp[i] = dp[i - 1] + dp[i - 2];
        dp_i = dp_i_1 + dp_i_2
        # 滚动更新
        dp_i_2 = dp_i_1
        dp_i_1 = dp_i
    return dp_i_1
```
上述例子就相当于把 DP table 的大小从 n 缩小到 2。我会在后文 对动态规划发动降维打击 进一步讲解这个压缩空间复杂度的技巧，
一般来说用来把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。

# 凑零钱问题
> 这是力扣第 322 题「 零钱兑换」：
给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，
问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。
> 比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。


## 1. 最优子结构
首先，这个问题是动态规划问题，因为它具有「最优子结构」的。**要符合「最优子结构」，子问题间必须互相独立**。
啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。

>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 
为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。
得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，「每门科目考到最高」这些子问题是互相独立，互不干扰的。
但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，不能同时达到满分，数学分数高，语文分数就会降低，反之亦然。
这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。
因为「每门科目考到最高」的子问题并不独立，语文数学成绩户互相影响，无法同时最优，所以最优子结构被破坏。


回到凑零钱问题，为什么说它符合最优子结构呢？
假设你有面值为 1, 2, 5 的硬币，你想求 amount = 11 时的最少硬币数（原问题），
如果你知道凑出 amount = 10, 9, 6 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1, 2, 5 的硬币），求个最小值，就是原问题的答案。
因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。


# 如何找到动态规划的状态转移关系
总结一下如何找到动态规划的状态转移关系：
1、明确 dp 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。
2、根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，一旦这一步完成，整个题目基本就解决了。
但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；
或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组







