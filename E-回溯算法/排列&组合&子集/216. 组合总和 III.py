"""
找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
- 只使用数字1到9
- 每个数字 最多使用一次
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

示例 1:
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。

示例 2:
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。

示例 3:
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。


提示:
2 <= k <= 9
1 <= n <= 60

"""
from typing import List

# 类似：C-回溯算法\排列&组合&子集\39. 组合总和(元素不重复可复选).py
# 区别在于数字不可复选，每次递归j+1，可以复选的话递归就是j

class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        # 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
        # - 只使用数字1到9
        # - 每个数字 最多使用一次
        ans = []
        
        def dfs(k, n, i=1, path=[]):
            if k == 0:
                if n == 0:
                    ans.append(path[:])
                return

            for j in range(i, 10):
                # 剪枝：因为数组有序，这里可以提前判断退出循环
                if n - j < 0:
                    break
                
                path.append(j)
                dfs(k-1, n-j, j+1, path) # j+1 避免重复选择
                path.pop()

        dfs(k, n)
        return ans
