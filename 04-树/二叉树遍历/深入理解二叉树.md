> 参考：https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-334dd/


# 深入理解前中后序
我先甩给你几个问题，请默默思考 30 秒：

1. 你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？
2. 请分析，后序遍历有什么特殊之处？
3. 请分析，为什么多叉树没有中序遍历？

# 二叉树遍历框架：

不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了：
```python
def traverse(root):
    if root is None:
        return
    # 前序位置
    traverse(root.left)
    # 中序位置
    traverse(root.right)
    # 后序位置
```
先不管所谓前中后序，单看 traverse 函数，你说它在做什么事情？

其实它就是一个能够遍历二叉树所有节点的一个函数，和你遍历数组或者链表本质上没有区别：
```python
from typing import List

# 迭代遍历数组
def traverse(arr: List[int]):
    for i in range(len(arr)):
        pass

# 递归遍历数组
def traverse(arr: List[int], i: int):
    if i == len(arr):
        return
    # 前序位置
    traverse(arr, i + 1)
    # 后序位置

# 迭代遍历单链表
def traverse(head: ListNode):
    p = head
    while p != None:
        p = p.next

# 递归遍历单链表
def traverse(head: ListNode):
    if head == None:
        return
    # 前序位置
    traverse(head.next)
    # 后序位置

```
* 单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，由于没办法简单改写成迭代形式，所以一般说**二叉树的遍历框架都是指递归的形式**。
* 你也注意到了，**只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。**
* 所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

比如说，如果让你倒序打印一条单链表上所有节点的值，你怎么搞？

实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作：
```python

# 递归遍历单链表，倒序打印链表元素
def traverse(head: ListNode) -> None:
    if head is None:
        return
    traverse(head.next)
    # 后序位置
    print(head.val)

```
结合上面那张图，你应该知道为什么这段代码能够倒序打印单链表了吧，本质上是利用**递归的堆栈**帮你实现了倒序遍历的效果。

教科书里只会问你前中后序遍历结果分别是什么，所以对于一个只上过大学数据结构课程的人来说，他大概以为**二叉树的前中后序只不过对应三种顺序不同的 List<Integer> 列表**。

但是我想说，**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：
- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

你注意本文的用词，我一直说**前中后序「位置」**，就是要和大家常说的**前中后序「遍历」**有所区别： 
* 你可以在前序位置写代码往一个 List 里面塞元素，那最后得到的就是前序遍历结果；
* 但并不是说你就不可以写更复杂的代码做更复杂的事。

你可以发现每个节点都有「唯一」属于自己的前中后序位置，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。

这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，

而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置

1. **二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，**
2. 你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

你也可以看到， 图论算法基础 把二叉树的遍历框架扩展到了图，并以遍历为基础实现了图论的各种经典算法，不过这是后话，本文就不多说了。


> 这里说一下我的函数命名习惯：
>
>1. **二叉树中用遍历思路**解题时函数签名一般是 void traverse(...)，**没有返回值**，靠更新外部变量来计算结果，
> 
>2. 而用**分解问题思路**解题时函数名根据该函数具体功能而定，而且一般**会有返回值**，返回值是子问题的计算结果。
> 
>3. 与此对应的，你会发现我在 **回溯算法核心框架** 中给出的函数签名一般也是**没有返回值**的 void backtrack(...)，
> 
>4. 而在 **动态规划核心框架** 中给出的函数签名是**带有返回值的 dp 函数**。这也说明它俩和二叉树之间千丝万缕的联系。
> 
>**虽然函数命名没有什么硬性的要求，但我还是建议你也遵循我的这种风格，这样更能突出函数的作用和解题的思维模式，便于你自己理解和运用。**


# 综上，遇到一道二叉树的题目时的通用思考过程是：

1. **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 traverse 函数配合外部变量来实现。 
2. **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。
3. 无论使用哪一种思维模式，你都要明白**二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。


# 后序位置的特殊之处
说后序位置之前，先简单说下中序和前序。

- 中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。
- 前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。
- 你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：

这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。

但这里面大有玄妙，意味着**前序位置的代码只能从函数参数中获取父节点传递来的数据**，而**后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：
1. 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？
2. 如何打印出每个节点的左右子树各有多少节点？

第一个问题可以这样写代码：
```python
# 二叉树遍历函数
def traverse(root: TreeNode, level: int) -> None:
    if not root:
        return
    # 前序位置
    print(f"节点 {root} 在第 {level} 层")
    traverse(root.left, level + 1)
    traverse(root.right, level + 1)

# 这样调用
traverse(root, 1)
```
第二个问题可以这样写代码：
```python

# 定义：输入一棵二叉树，返回这棵二叉树的节点总数
def count(root: TreeNode) -> int:
    if not root:
        return 0
    leftCount = count(root.left)
    rightCount = count(root.right)
    # 后序位置
    print(f"节点 {root} 的左子树有 {leftCount} 个节点，右子树有 {rightCount} 个节点")

    return leftCount + rightCount + 1
```
这两个问题的根本区别在于：
- 一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；
- 而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。

结合这两个简单的问题，你品味一下后序位置的特点，**只有后序位置才能通过返回值获取子树的信息**。

那么换句话说，**一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**

