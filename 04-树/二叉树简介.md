> 参考：
> https://juejin.cn/post/7035513034491576334
> https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%8F%89%E6%A0%91
>
> [零起步学算法 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/58skks/)

# 1.二叉树



二叉树是树形结构中的一种特殊形式。何为二叉？

1. 此树形结构中，每个节点 **最多** 有两个孩子节点。

2. 二叉树中节点也可能是**没有子节点**或者**一个子节点**，但不能超过两个子节点。
3. 二叉树的结点如果有孩子结点的话，使用 **左结点** 和 **右结点** 来区分



![image.png](https://pic.leetcode-cn.com/1600827914-SkTAKE-image.png)



## 二叉树的性质

1. 若二叉树的层次从0开始，则在二叉树的第 `i` 层至多有`2^i`个结点( i >=0 )。

2. 高度为 `k` 的二叉树最多有`2^(k+1) - 1`个结点 (k>=-1)。 (空树的高度为-1)

3. 对任何一棵二叉树，如果其叶子结点(高度为0)数为m, 分支度为2的结点数为n, 则`m = n + 1`。






# 2.满二叉树/完美二叉树(Perfect Binary Tree)

满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。
![](../07-优先队列&堆/堆/.二叉树分类_images/满二叉树.png)

## 满二叉树的性质
* 也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
* 判断是否满二叉树，可以通过求得二叉树的高度h和节点数nums，满足nums = (2^k) -1即可。



# 3.完全二叉树

- 对于一个有n个节点的二叉树，按照层级顺序来编号，则所有节点的编号为从1到n。
- 如果这个树的所有节点和同样深度的满二叉树的编号为1到n的节点位置相同，则这个二叉树为完全二叉树。

![image.png](https://pic.leetcode-cn.com/1600702053-eVKbeC-image.png)

## 完全二叉树的特点：
1. 叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。
2. 需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。



完全二叉树：

- 从形态上看完全二叉树是个 只缺了最后一行右边 的的三角形。

- 即：完全二叉树所有的结点按照从上到下、从左到右紧凑摆放，中间不会有缺失结点。

- 我们在之前学习过的 **堆**，就是完全二叉树的样子。

  
  

# 二叉树的遍历

![image.png](https://pic.leetcode-cn.com/1600829027-HfYEcu-image.png)



深度优先遍历与广度优先遍历，**在树的问题、图的问题中经常使用**！！



## 深度优先遍历

对于二叉树来说，深度优先遍历当遍历到一个新结点的时候，先遍历 **当前结点**，然后遍历 **当前结点的左子树**，最后遍历 **当前结点的右子树**。



遍历子树的逻辑是递归进行下去的。



![11-02-01.gif](https://pic.leetcode-cn.com/1600243005-srRBtG-11-02-01.gif)



### 深度优先遍历需要借助「栈」实现

对于深度优先遍历而言，后遍历到的结点先输出，符合 **后进先出** 的规律，因此可以借助「栈」实现。下面的动画模拟了整个过程。

![11-01-04.gif](https://pic.leetcode-cn.com/1600839848-xxGrRS-11-01-04.gif)





说明：

- 统一的逻辑是：首先将根结点入 **栈**，然后将结点出栈，每一个出栈结点做如下操作：

  - 如果出栈结点有右结点，把右结点加入栈顶；
  - 如果出栈结点有左结点，把左结点加入栈顶；
- 直到没有结点可以入栈，依次将结点从栈顶出栈，每次出栈遵守上面的规则，只要有孩子结点，就依次入栈。
- **出栈结点的顺序是深度优先遍历的顺序。**
- 由于我们人为规定先遍历左子树的所有结点，再遍历右子树的所有结点。因此左、右结点的入栈顺序是：先右结点再左结点。



---



## 广度优先遍历

由于广度优先遍历在树形结构上 **按照层次顺序**，即：从根结点向下逐层进行遍历，并且同一层结点的遍历顺序为从左到右。因此，在树形结构中，广度优先遍历也叫 **层序遍历**。



![11-02-02.gif](https://pic.leetcode-cn.com/1600243554-XabODO-11-02-02.gif)



### 广度优先遍历需要借助「队列」实现

对于广度优先遍历而言，先遍历到的结点先输出，符合 **先进先出** 的规律，因此可以借助「队列」实现。下面的动画模拟了整个过程。



![11-01-05.gif](https://pic.leetcode-cn.com/1600839868-oWlnGp-11-01-05.gif)

**说明：**

- 统一的逻辑是：首先将根结点加入 **队列**，然后将结点出队尾，每一个出队结点做如下操作：

  - 如果出队结点有左结点，把左结点加入队尾；
  - 如果出队结点有右结点，把右结点加入队尾；
- 直到没有结点可入队，依次将结点从队首出队，每次出队遵守上面的规则，只要有孩子结点，就依次入队。
- **出队结点的顺序是广度优先遍历的顺序。**







### 「深度优先遍历」与「广度优先遍历」的比较
「深度优先遍历」与「广度优先遍历」在算法的世界里发挥了巨大的作用：

- 深度优先遍历和广度优先遍历都需要借助相应的数据结构，对即将访问到的元素在适当的时机 **缓存** ：
  - 深度优先遍历使用的是**栈**，
  - 广度优先遍历使用的是**队列**；
- 遍历可以用于搜索，找到 **所有** 需要的元素；
- 深度优先遍历由于其本身的特性，在面对巨大的结果集的时候，能够使用较少的性能消耗，它的另一个名字叫 **回溯算法** ，我们会在下一章节向大家介绍；
- 基于「两点之间，线段最短」，**广度优先遍历可以用于搜索无向图的最短路径**，这一点是非常关键的。













































