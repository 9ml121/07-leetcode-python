"""
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。



示例 1：
输入：nums = [3,2,3]
输出：3

示例 2：
输入：nums = [2,2,1,1,1,2,2]
输出：2


提示：
n == nums.length
1 <= n <= 5 * 10^4
-10^9 <= nums[i] <= 10^9


进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
"""
from typing import List

# todo 摩尔投票算法
"""
符合直觉的做法是利用额外的空间去记录每个元素出现的次数，并用一个单独的变量记录当前出现次数最多的元素。
但是这种做法空间复杂度较高，有没有可能进行优化呢？ 答案就是用"投票算法"。
"""


class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # 返回nums数组的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素
        # 时间复杂度为 O(n)、空间复杂度为 O(1)
        count = 0
        majority = None

        # 投票算法的原理是通过不断消除不同元素直到没有不同元素，剩下的元素就是我们要找的元素。
        # 注意这里的关键是消除不同的数。
        for num in nums:
            if count == 0:
                majority = num
            count += (1 if num == majority else -1)

        # 背后的原理非常简单，即最坏的情况下非众数中的每一个数都和众数进行消除，那么剩下的是众数。其他情况则显然剩下的也是众数本身。
        # 投票算法前提：给定的数组总是存在多数元素
        return majority


"""
# 摩尔投票算法的原理如下：
1.初始化候选元素 candidate 为数组的第一个元素，计数器 count 为 1。
2.遍历数组中的每个元素：
3.如果 count 为 0，表示当前的候选元素已经被消耗完，需要重新选择候选元素。将当前元素设为新的候选元素，并将 count 设为 1。
4.如果当前元素与候选元素 candidate 相同，则将 count 加 1，表示当前候选元素的计数增加一个。
5.如果当前元素与候选元素 candidate 不同，则将 count 减 1，表示当前候选元素的计数减少一个。
6.最终，候选元素 candidate 的值就是出现次数最多的元素。
这个算法的核心思想是利用了出现次数超过一半的元素的特点。在遍历过程中，将候选元素与其他元素进行抵消。
由于题目已经明确假设数组中至少有一个元素出现次数超过数组长度的一半，那么最终剩下的候选元素就是出现次数最多的元素。

# 算法的正确性可以通过以下观察得出：
当候选元素的计数减到 0 时，说明当前的候选元素已经被消耗完，需要重新选择候选元素。
    这是因为如果某个元素出现次数超过数组长度的一半，那么其他元素的出现次数总和必然无法抵消这个元素的出现次数，因此重新选择候选元素不会改变最终的结果。
最终剩下的候选元素必然是出现次数最多的元素。
    这是因为如果存在一个元素的出现次数超过数组长度的一半，那么其他元素的出现次数总和必然无法抵消这个元素的出现次数。
    因此，即使在抵消过程中，候选元素的计数可能会被其他元素消耗掉，但最终剩下的候选元素仍然满足出现次数超过一半的条件。

摩尔投票算法的时间复杂度是 O(n)，其中 n 是数组的长度。由于算法只使用了常数个变量来保存候选元素和计数器，因此空间复杂度是 O(1)。

# 摩尔投票算法主要适用于以下类型的问题：

- 寻找出现次数超过一半的元素：
    摩尔投票算法最常见的应用场景是在一个数组或序列中寻找出现次数超过一半的元素。
    该算法可以在 O(1) 的空间复杂度下找到出现次数最多的元素。
- 寻找出现次数超过 1/k 的元素：
    摩尔投票算法的扩展形式可以用于寻找出现次数超过总数的 1/k 的元素，其中 k 是一个正整数。
    通过维护 k-1 个计数器和对应的候选元素，可以在 O(k) 的空间复杂度下找到出现次数最多的元素。

消除数组中多个不同元素的问题：除了寻找出现次数超过一半的元素外，摩尔投票算法还可以用于消除数组中多个不同元素的情况。
在这种情况下，可以通过维护多个候选元素和对应的计数器来实现消除。

需要注意的是，摩尔投票算法只适用于具备一定特征的问题，即问题中存在出现次数超过一定比例的元素。
在其他类型的问题中，摩尔投票算法可能并不适用。
在使用摩尔投票算法时，需要根据问题的特点进行合理的分析和判断。
"""