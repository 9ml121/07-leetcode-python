"""
给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最小操作数。

在一次操作中，你可以使数组中的一个元素加 1 或者减 1 。

 

示例 1：

输入：nums = [1,2,3]
输出：2
解释：
只需要两次操作（每次操作指南使一个元素加 1 或减 1）：
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
示例 2：

输入：nums = [1,10,2,9]
输出：16
 

提示：

n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109
"""

from typing import List
"""
数学归纳法：
1.如果有a 和 b 两个数（a < b），则使这两个数都等于x，则x在[a, b]范围内，移动次数最少，且步数为 b - a。
2.当将nums中所有元素都变成nums数组中的中位数时，移动次数最少。
本题的核心点就是寻找中位数

https: // leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solutions/844068/fen-xi-wei-shi-yao-yao-pai-xu-xuan-qu-zh-ec7j

示例1：[0, 1, 2, 6, 8]
通过对数据的观察，可以得知，对首尾的两个数 0, 8 最小的移动次数就是在[0, 8] 之间任意找一个数，他们的固定移动次数都是 8；
如果尝试在这个区间外找一个数来计算移动次数，如找 - 1，则 0和8 的移动次数则为 10
同理，我们对 1和6 进行最小次数移动的话， [1, 6] 中的任意数，他们固定移动 5次

最后剩下一个中间的数 2，不移动的话，最小次数为 0

对这个参考数的选取则为[0, 8] ∩ [1, 6] ∩ [2] = 2，他们的最小移动次数就是 8+5+0 = 13

上述思路可以确定，本题的核心点就是寻找中位数，上面分析的是奇数数组，下面分析偶数数组

示例2： [0, 1, 2, 6]
1、在[0, 6] 任意找一个数，固定最小次数 6
2、在[1, 2] 任意找一个数，固定最小次数 1
中间数的选取条件为 [0, 6] ∩ [1, 2] = [1, 2]，即 1或2 都行，最小移动次数为 6+1 = 7
"""

class Solution:
    def minMoves2(self, nums: List[int]) -> int:
        # 返回使所有数组元素相等需要的最小操作数
        # 在一次操作中，你可以使数组中的一个元素加 1 或者减 1 。
        nums.sort()
        l = 0
        r = len(nums) - 1
        ans = 0
        while l <= r:
            ans += nums[r] - nums[l]
            l += 1
            r -= 1

        return ans
