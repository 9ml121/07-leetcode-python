"""
给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。

示例 1：
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

示例 2：
输入：n = 0
输出：0

示例 3：
输入：n = 1
输出：0

提示：
0 <= n <= 5 * 10^6
"""


# 质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数

# 方法1：暴力枚举法：当n达到10^5,会超时
# 时间复杂度：N * log(N)
class Solution:
    def countPrimes(self, n: int) -> int:
        # 判断一个数是否为质数（素数），注意：1不是质树，2是质数
        def is_prime(num: int):
            if num == 1:
                return False
            if num == 2:
                return True
            for i in range(2, int(num ** 0.5) + 1):  # 优化：只需遍历到 sqrt(num)
                if num % i == 0:
                    return False
            return True

        res = 0
        for i in range(2, n):
            if is_prime(i):
                res += 1
        return res


'''
方法2：埃氏筛：https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95
枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。
接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。
1.我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。
2.我们设isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。
    从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，
    这样在运行结束的时候我们即能知道质数的个数。
3.这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，
    因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。


埃氏筛 假定我们要求100以内的质数，我们从2开始遍历。 [2,3,4,5,6,7,8,9,10,11,12,13,14,15...]
遍历到2，2是质数，于是我们把2的所有倍数全部删除，比如4、6、8、10...... 
遍历到3，3是质数，于是我们把3的所有倍数全都删除，比如6、9、12、15...... 
遍历到4，4是合数已经删除，继续遍历，
以此类推即可找到范围内所有的素数
'''


class Solution2:
    def countPrimes(self, n: int) -> int:
        # 求小于给定数 n 的质数数量
        if n < 2:
            return 0

        isPrime = [1] * n  # n=26, [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
        isPrime[0] = isPrime[1] = 0
        for i in range(2, int(n ** 0.5) + 1):  # 2,3,4,5
            # 2。先用2去筛，把2留下，把2的倍数剔除掉；
            if isPrime[i]:
                for j in range(i * i, n, i):  # 优化：这里直接从 i^2开始筛选
                    # 筛选2:4,6,8,10,12,14,16,18,20,22,24
                    # 筛选3:9,12,15,18,21,24
                    # 筛选5:25
                    isPrime[j] = 0
                    # 最后剩下[2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]
        # print(isPrime)
        return sum(isPrime)


"""
方法3：线性筛(欧拉筛)
此方法不属于面试范围范畴，本节只做简单讲解。

埃氏筛其实还是存在冗余的标记操作，比如对于 12 这个数，它会同时被 2,3 两个数标记为合数，
因此我们优化的目标是让每个合数只被标记一次，这样时间复杂度即能保证为 O(n)，这就是我们接下来要介绍的线性筛。

1.相较于埃氏筛，我们多维护一个 primes 数组表示当前得到的质数集合。
  我们从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组。
2.另一点与埃氏筛不同的是，「标记过程」不再仅当 x 为质数时才进行，而是对每个整数 x 都进行。
    对于整数 x，我们不再标记其所有的倍数 x⋅x, x⋅(x+1),…，而是只标记质数集合中的数与 x 相乘的数，
    即 x⋅primes[0],x⋅primes[1],…，且在发现 x mod primes =0 的时候结束当前标记。
3.核心点在于：
    如果 x 可以被 primes[i]整除，那么对于合数 y=x⋅primes[i+1]而言，
    它一定在后面遍历到 (x/primes[i]) ⋅primes[i+1]这个数的时候会被标记，
    其他同理，这保证了每个合数只会被其「最小的质因数」筛去，即每个合数被标记一次。
4.注意：线性筛因为有取模判断，因此只有在数据量很大的时候，才会比埃氏筛性能更好

线性筛还有其他拓展用途，有能力的读者可以搜索关键字「积性函数」继续探究如何利用线性筛来求解积性函数相关的题目。
"""


class Solution3:
    def countPrimes(self, n: int) -> int:
        if n < 2:
            return 0
        is_prime = [1] * n  # 初始时全部设置为 True
        primes = []
        for i in range(2, n):
            if is_prime[i]:  # i 是质数
                primes.append(i)

            for p in primes:
                if i * p >= n:
                    break
                is_prime[i * p] = 0
                if i % p == 0:
                    break
        return len(primes)


if __name__ == '__main__':
    print(Solution().countPrimes(25))
    print(Solution().countPrimes(3))
    print(Solution2().countPrimes(25))
