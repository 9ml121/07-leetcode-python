"""
题目解析和算法源码
华为OD机试 - 最长子字符串的长度(二)（Java & JS & Python & C & C++）-CSDN博客

OJ用例
题解 - 最长子字符串的长度(二) - Hydro

题目描述
给你一个字符串 s，字符串 s 首尾相连成一个环形，请你在环中找出 'l'、'o'、'x' 字符都恰好出现了偶数次最长子字符串的长度。

输入描述
输入是一串小写的字母组成的字符串

输出描述
输出是一个整数

备注
1 ≤ s.length ≤ 5 * 10^5
s 只包含小写英文字母
用例1
输入
alolobo
输出
6
说明
最长子字符串之一是 "alolob"，它包含 'l'，'o' 各2个，以及 0 个 'x'。

用例2
输入
looxdolx
输出
7
说明
最长的子字符串是"oxdolxl"，由于是首尾连接在一起的，所以最后一个 'x' 和开头的 'l' 是连接在一起的，此字符串包含 2 个 'l'，2个'o'，2个'x'

用例3
输入
bcbcbc
输出
6
说明
这个示例中，字符串 "bcbcbc" 本身就是最长的，因为 'l'、'o'、'x' 都出现了 0 次。
"""

# todo 状态压缩
"""
题目解析
本题其实就是:05-字符串&整数&哈希/位运算/1371. 每个元音包含偶数次的最长子字符串.py的变形体。

看本题前需要先把上面题目搞懂，否则本题解法看不懂。
本题与上面题目的区别在于，本题的主串s是环，即当遍历到s串尾部时，可以继续环动到s串头部。

本题如果继续按照前面leetcode那题的思路解题，则会发现使用哈希表时，不能只单单记录某个状态的最早出现位置。

而是需要记录某个状态的出现的所有位置（需要按照先后顺序依次记录）。

因为，本题随着绕环运动，黑色部分会逐渐侵蚀掉一些位置，而这些被侵蚀的位置，可能就是某个状态最早出现的位置，当该位置被侵蚀后，我们需要更新对应状态到新的最早出现位置。

如果使用队列记录某个状态出现的所有位置（按照先后顺序依次记录），那么队列头部记录的就是该状态的最早出现位置，如果该位置被侵蚀，那么我们就弹出队头，使用新的队头元素作为对应状态的最早出现位置。
"""
# 输入：小写字母组成的字符串
s = input()

# 输出：环形字符串中l,o,x恰好出现偶数次的最长子串长度
maxLen = 0

# 1. status二进制的3位数值，分别表示l,o,x出现的奇偶次数，0代表偶数次，1代表奇数次
# l:0b100, o:0b010, x:0b001， 3个数组合，总共是有8个状态
status = 0b000
# 2.注意：之前maps[i]表示状态为i在s中最早出现的位置,初始状态值-2，表示没有出现过
# maps = [-2] * 8
# maps[0] = -1
# 这里环形数组，maps[i] 用于记录 状态i 出现的过的所有位置
maps = [[] for _ in range(8)]
maps[0].append(-1)


n = len(s)
for i in range(n*2):
    # 第二轮时，i>=n，此时i需要对n求余，避免后面越界
    c = s[i % n]
    # 二进制异或操作：
    if c == 'l':
        status ^= 0b100
    elif c == 'o':
        status ^= 0b010
    elif c == 'x':
        status ^= 0b001

    if i < n:
        # 第一轮时，i ∈ [0..n), 左闭右开
        # 记录该状态出现过的所有位置
        maps[status].append(i)

    # 第二轮时，需要判断status最早出现位置和当前位置长度是否超过n
    while maps[status]:
        if i - maps[status][0] > n:
            maps[status].pop(0)
        else:
            maxLen = max(maxLen, i - maps[status][0])
            break

print(maxLen)
