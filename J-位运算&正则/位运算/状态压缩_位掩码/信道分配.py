"""
题目解析和算法源码
https://blog.csdn.net/qfc_128220/article/details/127607871

题目描述
算法工程师小明面对着这样一个问题 ，需要将通信用的信道分配给尽量多的用户:

信道的条件及分配规则如下:

所有信道都有属性:”阶”。阶为 r的信道的容量为 2^r比特;
所有用户需要传输的数据量都一样:D比特;
一个用户可以分配多个信道，但每个信道只能分配给一个用户;
只有当分配给一个用户的所有信道的容量和>=D，用户才能传输数据;
给出一组信道资源，最多可以为多少用户传输数据?

输入描述
第一行，一个数字 R。R为最大阶数。

0<=R<20

第二行，R+1个数字，用空格隔开。代表每种信道的数量 Ni。按照阶的值从小到大排列。

0<=i<=R,0<=Ni<1000.

第三行，一个数字 D。D为单个用户需要传输的数据量。

0<D<1000000

输出描述
一个数字（代表最多可以供多少用户传输数据）

用例1
输入
5
10 5 0 1 3 2
30
输出
4
说明
最大阶数为5.

信道阶数	信道容量	信道个数
0	1	10
1	2	5
2	4	0
3	8	1
4	16	3
5	32	2
单个用户需要传输的数据量为30

可能存在很多分配方式，举例说明:

分配方式1:

32 * 1 = 32
32 * 1 = 32
16 * 2 = 32
16 * 1 + 8 * 1 + 2 * 3 =30
剩下 2 * 2 + 1 * 10 = 14 不足以再分一个用户了

分配方式2:

16 * 1 + 8 * 1 + 2 * 3 =30
16 * 1 + 2 * 2 + 1 * 10 =30
32 * 1 =32
32 * 1 = 32
剩下 16*1 = 16 不足以再分一个用户了。

分配方式3:

16 * 1 + 8 * 1 + 2 * 3 =30
16 * 1 + 2 * 2 + 1 * 10 = 30
32 * 1 = 32
32 * 1 = 32
恰好用完。

虽然每种分配方式剩下的容量不同，但服务的用户数量是一致的。因为这个问题中我们只关心服务的用户数，所以我们认为这些分配方式等效。


"""
# todo 状态压缩(困难题)

# 输入
# R为最大阶数，0<=R<20
R = int(input())
# R+1个数字,代表每种信道的数量 Ni。按照阶的值从小到大排列。0<=Ni<1000.
N = list(map(int, input().split()))
# D为单个用户需要传输的数据量。0<D<1000000
D = int(input())


# 输出：一个数字（代表最多可以供多少用户传输数据）
def bin2int(bin_s: list):
    # 将二进制转换为10进制
    ans = 0
    # 从低位到高位
    bin_s.reverse()
    n = len(bin_s)
    for i in range(n):
        ans += bin_s[i] * (1 << i)
    return ans

# print(bin2int([1,0]))

# 两个二进制减法运算，返回N是否大于bin_d
def calc(N: list, bin_d: list):
    # bin_d=[1, 1, 1, 1, 0]
    #     N=[3, 1, 0, 5, 10] # 从高位到低位
    for i in range(len(N)):
        if N[i] >= bin_d[i]:
            N[i] -= bin_d[i]
        else:
            # 如果N当前位数比bin_d要小，优先向N低位借数，避免浪费，如果低位不够借，就向高位借
            # 如果都借不到，证明N比bin_d要小，返回False
            if bin2int(N[i:]) >= bin2int(bin_d[i:]):
                # 低位可以借,将借的数字转移到下一个低位
                diff = bin_d[i] - N[i]
                N[i] = 0
                N[i+1] -= diff * 2
            else:
                # 低位借不到，向高位借1个
                j = i-1
                while j >= 0:
                    if N[j] > 0:
                        N[j] -= 1
                        return True
                    else:
                        j -= 1

                return False
    # print(N)
    return True


def main():
    # 2.将D转换为二进制
    bin_d = list(map(int, list(bin(D)[2:])))
    # print(f'bin_d={bin_d}')

    ans = 0
    # 3.让N和bin_d的长度保持相同
    while len(N) > len(bin_d):
        ans += N.pop()

    while len(N) < len(bin_d):
        N.append(0)  # 高位加0不影响最后结果

    # 4.让N和bin_d都是高位到低位的顺序
    N.reverse()

    
    # 5.进行两个二进制减法运算
    while calc(N, bin_d):
        ans += 1

    return ans


print(main())
