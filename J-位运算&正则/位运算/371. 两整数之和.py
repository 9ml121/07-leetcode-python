"""
给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。

 
示例 1：
输入：a = 1, b = 2
输出：3

示例 2：
输入：a = 2, b = 3
输出：5
 

提示：
-1000 <= a, b <= 1000
"""



# todo 前置知识1：二进制异或是一种不进位的加减法
"""
a = 5 = 0101
b = 4 = 0100

a ^ b 如下：

0 1 0 1
0 1 0 0
-------
0 0 0 1
"""

# a ^ b 得到了一个无进位加法结果，如果要得到 a + b 的最终值，我们还要找到进位的数，把这二者相加。
# todo 前置知识2：在位运算中，我们可以使用 与操作 和 移位 获得进位
"""
a = 5 = 0101
b = 4 = 0100

a & b 如下：

0 1 0 1
0 1 0 0
-------
0 1 0 0

"""
# 由计算结果可见，0100 并不是我们想要的进位，1 + 1 所获得的进位应该要放置在它的更高位，即左侧位上，
# 因此我们还要把 0100 左移一位，才是我们所要的进位结果。

"""
总结一下：
1. a + b 的问题拆分为(a 和 b 的无进位结果) + (a 和 b 的进位结果)
2. 无进位加法使用异或运算计算得出
3. 进位结果使用与运算和移位运算计算得出
4. 循环此过程，直到进位为 0
"""

# todo 前置知识3：有符号的二进制码：原码，反码和补码
"""
1.原码：在二进制码中，我们采用最高位作为符号位的方法来区分正负数。正数的符号位为0，负数的符号位为1。
原码就是直接将整数的绝对值转换成二进制形式，最高位是符号位。
例如，-3 的原码是 0b00000000000000000000000000000011。

2.反码：负数的反码是将其原码的每一位取反，即0变成1，1变成0。
例如，-3 的反码是 0b11111111111111111111111111111100。

3.补码：负数的补码是将其反码加1。也就是说，我们先计算出反码，然后在反码的基础上加1。
例如，-3 的补码是 0b11111111111111111111111111111101。
"""

# todo 前置知识4：python中负数的二进制码特殊处理
"""
Python，Java, C++ 等语言中的数字都是以 补码 形式存储的。
需要注意的是，Python 中没有位数这一概念，所以它认为 '0b11111111111111111111111111111101' 是正数。
不要被首位的1所迷惑，因为在 Python 中，1 和 -1 的二进制表示分别是 '0b1' 和 '-0b1'。

Python中的整型是补码形式存储的
Python中bin一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，方便查看
Python中bin一个负数（十六进制表示），输出的是对应的二进制表示。（注意此时）

# python整数类型为Unifying Long Integers, 即无限长整数类型。
# 也就是说你一直循环左移并不会存在溢出的现象，这就需要我们手动对 Python 中的整数进行处理，手动模拟 32bit 有符号整型加法

获取负数的补码： 需要将数字与十六进制数 0xffffffff 相与。
可理解为舍去此数字 32 位以上的数字（将 32 位以上都变为 000 ），从无限长度变为一个 32 位整数。

返回前数字还原： 若补码 a 为负数（ 0x7fffffff 是最大的正数的补码 ），需执行 ~(a ^ x) 操作，将补码还原至 Python 的存储格式。 
a ^ x 运算将 1 至 32 位按位取反； ~ 运算是将整个数字取反；因此， ~(a ^ x) 是将 32 位以上的位取反，1 至 32 位不变。

"""

class Solution:
    def getSum(self, a: int, b: int) -> int:
        # 不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和
        x = 0xffffffff
        a, b = a & x, b & x
     
        # 循环，当进位为 0 时跳出
        while b != 0:
            # 计算进位：求与之后左移一位，可以表示进位
            carry = (a & b) << 1 
            # a:无进位和， b:进位
            a = a ^ b
            b = carry & x
            # print((a, b))
            
        return a if a <= 0x7fffffff else ~(a ^ x)

  
