"""
给你一个二进制数组 nums 。

你可以对数组执行以下操作 任意 次（也可以 0 次）：

选择数组中 任意连续 3 个元素，并将它们 全部反转 。
反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。

请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。

 

示例 1：
输入：nums = [0,1,1,1,0,0]
输出：3

解释：
我们可以执行以下操作：

选择下标为 0 ，1 和 2 的元素并反转，得到 nums = [1,0,0,1,0,0] 。
选择下标为 1 ，2 和 3 的元素并反转，得到 nums = [1,1,1,0,0,0] 。
选择下标为 3 ，4 和 5 的元素并反转，得到 nums = [1,1,1,1,1,1] 。

示例 2：
输入：nums = [0,1,1,1]
输出：-1

解释：
无法将所有元素都变为 1 。

 

提示：
3 <= nums.length <= 10^5
0 <= nums[i] <= 1
"""

# 分类讨论：
# 如果 nums[0] = 1，无需修改，问题变成剩下 n−1 个数如何操作。接下来考虑 nums[1]。
# 如果 nums[0] = 0，修改，问题变成剩下 n−1 个数如何操作。接下来考虑 nums[1]。
# 所以从左到右遍历数组，一边遍历一边修改。


class Solution:
    def minOperations(self, nums: list[int]) -> int:
        # 选择数组中 任意连续 3 个元素，并将它们 全部反转，返回将 nums 中所有元素变为 1 的 最少 操作次数
        n = len(nums)
        ans = 0
        # 1.遍历 nums,如果第一位是 1，不需要翻转；否则需要翻转一次，利用异或运算，翻转后面 2 位
        for i in range(n-2):
            if nums[i] == 0:
                ans += 1
                nums[i+1] ^= 1
                nums[i+2] ^= 1

        # 2.判断nums最后 2 位是否都为 1，如果不是，证明无法全部变成 1 ，返回 -1，否则返回 ans
        return ans if nums[-1] and nums[-2] else -1


# 进阶题：将任意连续 3 个元素改为任意 x个元素
# 3192. 使二进制数组全部等于 1 的最少操作次数 II.py
# 995. K 连续位的最小翻转次数
