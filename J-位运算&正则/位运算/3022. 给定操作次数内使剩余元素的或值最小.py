"""
给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。

一次操作中，你可以选择 nums 中满足 0 <= i < nums.length - 1 的一个下标 i ，并将 nums[i] 和 nums[i + 1] 替换为数字 nums[i] & nums[i + 1] ，其中 & 表示按位 AND 操作。

请你返回 至多 k 次操作以内，使 nums 中所有剩余元素按位 OR 结果的 最小值 。

 

示例 1：

输入：nums = [3,5,3,2,7], k = 2
输出：3
解释：执行以下操作：
1. 将 nums[0] 和 nums[1] 替换为 (nums[0] & nums[1]) ，得到 nums 为 [1,3,2,7] 。
2. 将 nums[2] 和 nums[3] 替换为 (nums[2] & nums[3]) ，得到 nums 为 [1,3,2] 。
最终数组的按位或值为 3 。
3 是 k 次操作以内，可以得到的剩余元素的最小按位或值。
示例 2：

输入：nums = [7,3,15,14,2,8], k = 4
输出：2
解释：执行以下操作：
1. 将 nums[0] 和 nums[1] 替换为 (nums[0] & nums[1]) ，得到 nums 为 [3,15,14,2,8] 。
2. 将 nums[0] 和 nums[1] 替换为 (nums[0] & nums[1]) ，得到 nums 为 [3,14,2,8] 。
3. 将 nums[0] 和 nums[1] 替换为 (nums[0] & nums[1]) ，得到 nums 为 [2,2,8] 。
4. 将 nums[1] 和 nums[2] 替换为 (nums[1] & nums[2]) ，得到 nums 为 [2,0] 。
最终数组的按位或值为 2 。
2 是 k 次操作以内，可以得到的剩余元素的最小按位或值。
示例 3：

输入：nums = [10,7,10,3,9,14,9,4], k = 1
输出：15
解释：不执行任何操作，nums 的按位或值为 15 。
15 是 k 次操作以内，可以得到的剩余元素的最小按位或值。
 

提示：

1 <= nums.length <= 105
0 <= nums[i] < 230
0 <= k < nums.length
"""

# todo 位运算
class Solution:
    def minOrAfterOperations(self, nums: list[int], k: int) -> int:
        # 至多 k 次操作以内，使 nums 中所有剩余元素按位 OR 结果的 最小值
        n = max(nums).bit_length()
        #  1.在考虑每一位最终是否为零时，怎么保存住之前那些确定最终结果可以为0的位。使用mask 巧妙地解决了这个问题。
        ans = mask = 0
        for b in range(n-1, -1, -1):
            # 从高到低考虑：答案在这一位能不能是 0？
            mask |= 1 << b
            cnt = 0  # 操作次数
            and_res = -1  # -1 在 python 里在二进制下全为1, 满足任何数和它进行与运算都是它本身
            for x in nums:
                # 尝试从左到右合并（忽略低位和必须是 1 的位），如果合并出 0，就开始合并下一段。
                and_res &= x & mask
                if and_res:
                    cnt += 1  # 合并 x，操作次数加一
                else:
                    and_res = -1  # 准备合并下一段
                    
            if cnt > k or cnt == len(nums):
                ans |= 1 << b  # 答案的这个比特位必须是 1
                mask ^= 1 << b  # 后面不考虑这个比特位,这一位一定为1 消除这一位的影响
        return ans


# 拓展阅读：在 python3 中，为什么-1 的二进制表示位都为 1
"""
在Python 3中，-1的二进制表示位都为1，这是因为计算机采用补码（two's complement）形式来存储和运算负数。补码是一种将正负数统一表示并便于计算的方法，对于负数而言，其补码是在其绝对值的二进制表示的基础上按位取反（即0变1，1变0），然后加1得到。以下是具体分析：

负数的补码表示：

负数在计算机中以补码形式存储；
对于-1，先取其绝对值的二进制形式（1为0001），按位取反得到1110，再加1得到1111。

原码、反码和补码：
    原码是数字的直接二进制表示，负数的最高位为符号位（1表示负数）；
    反码是负数原码除符号位外各位取反；
    补码是在反码基础上加1。

补码的优势：
使用补码，可以将减法转换为加法，简化计算机的硬件设计；
补码能正确表示0，避免出现正零和负零的混淆。

综上所述，由于补码的这些特性，Python和其他编程语言通常采用补码方式来处理负数，这也是为什么Python 3中-1的二进制表示位都为1的原因。
"""

# 思路
"""
以 [5,2,3,6] 为例说明，这四个数的二进制表示如下：  
101
010
011
110
​
设 k=2。从高到低考虑：答案在这一位能不能是 0？
1.最高位有两个 1，合并掉这两个 1 需要操作 2 次（≤k），所以答案的最高位可以是 0。
2.对于次高位，我们需要通过一连串的合并，让合并结果的最高位和次高位都是 0。
    数组前两个数（只看最高位和次高位）可以合并成 0，操作 1 次。
    数组后两个数（只看最高位和次高位）无法合并成 0，那么用前两个数合并出来的 0，与后两个数合并，操作 2 次，得到 0。
    所以一共要操作 3 次才能让最高位和次高位都是 0，无法做到，所以答案的次高位一定是 1。
3.对于最低位，我们需要通过一连串的合并，让合并结果的最高位和最低位都是 0。注意我们无需考虑次高位，因为前面已经确定答案这一位是 1 了。数组前两个数（只看最高位和最低位）可以合并成 0，操作 1 次。数组后两个数（只看最高位和最低位）也可以合并成 0，操作 1 次。一共操作 2 次，所以答案的最低位可以是 0。

综上所述，答案的二进制表示为 010，即十进制 2。

作者：灵茶山艾府
链接：https://leetcode.cn/problems/minimize-or-of-remaining-elements-using-operations/solutions/2622658/shi-tian-fa-pythonjavacgo-by-endlesschen-ysom/
"""
