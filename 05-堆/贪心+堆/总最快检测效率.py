"""
题目描述
在系统、网络均正常的情况下组织核酸采样员和志愿者对人群进行核酸检测筛查。
每名采样员的效率不同，采样效率为N人/小时。
由于外界变化，采样员的效率会以M人/小时为粒度发生变化，M为采样效率浮动粒度，M=n*10%，输入保证N*10%的结果为整数。
采样员效率浮动规则：采样员需要一名志愿者协助组织才能发挥正常效率，在此基础上，每增加一名志愿者，效率提升1M，最多提升3M；如果没有志愿者协助组织，效率下降2M。
怎么安排速度最快？求总最快检测效率（总检查效率为各采样人员效率值相加）。

输入描述
第一行：第一个值，采样员人数，取值范围[1, 100]；第二个值，志愿者人数，取值范围[1, 500]；
第二行：各采样员基准效率值（单位人/小时），取值范围[60, 600]，保证序列中每项值计算10%为整数。

输出描述
第一行：总最快检测效率（单位人/小时）

用例
输入	2 2
        200 200
输出	400
说明	输入需要保证采样员基准效率值序列的每个值*10%为整数。
"""

'''
https://fcqian.blog.csdn.net/article/details/128232930
题目解析
用例意思是：
有两个采样员，两个志愿者。
两个采样员的正常效率都是200，但是要给每个采样员配一个志愿者才能发挥正常效率。
现在刚好采样员和志愿者是一比一，因此可以发挥出总效率是：200 + 200 = 400。
如果，我们给一个采样员配两个志愿者，那么该采样员发挥的效率是：200 + 200 * 10% = 220。
但是另一名采样员就没有志愿者了，因此发挥不了正常效率，200 - 200 * 20% = 160，此时总效率是220 + 160 = 380。
因此，总最快效率是400。

需要注意的是，用例中采样员的正常效率只是凑巧相同，很有可能出现一个采样员的正常效率极高，一个采样员的正常效率极低的情况。

我的解题思路如下：
首先分两种情况：
1、志愿者数量少于采样员
2、志愿者数量不少于采样员

对于情况1，我们应该将不多的志愿者优先分配给高效率的采样员，默认一比一分配。
接下来，我们应该考虑，剥夺低效率的采样员的志愿者  给 高效率的采样员，只要 高效率采样员增加的10%的效率   可以大于  低效率采样员减少的20%的效率。
其中还要考虑，高效率的采样员最多可以追加3个志愿者，即最多增加30%的效率。如果最高效率的采样员已经提升30%效率，则第二高效率的采样员称为最高优先级，继续上面剥夺逻辑。

对于情况2，我们应该先按一比一的方式，给每个采样员分配一个志愿者。
然后，如果还多出志愿者的话，则优先分配给高效率的采样员，同样需要注意每个采样员最追加3个志愿者。
当多出的志愿者分配完后，我们需要考虑剥夺低效率的采样员的志愿者  给 高效率的采样员，只要 高效率采样员增加的10%的效率   可以大于  低效率采样员减少的20%的效率。逻辑同情况1。
另外，对于情况2而言，如果采样员：志愿者 的比例，超过了1：4，那么超出4倍采样员范围的志愿者将没有效率提升作用，因此有效志愿者数量最多是四倍的采样员数量。

# 最佳解法：优先级队列
'''


import queue

# 输入获取
x, y = map(int, input().split())
arr = list(map(int, input().split()))


def getAdd(s):
    """
    :param s: 采样员对象
    :return: 假设采样员s增加一名志愿者能提升的效率
    """
    if s.volunteer == 0:  # 如果当前采样员没有志愿者，则新增一名志愿者可以提升base * 20%的效率
        return s.base * 0.2
    elif s.volunteer <= 3:  # 如果当前采样员搭配的志愿者数量小于等于3个，则说明再新增一个志愿者，可以提升base * 10%的效率
        return s.base * 0.1
    else:  # 如果当前采样员已有4个志愿者，则再新增一个志愿者，不能提升效率，即提升效率为0
        return 0


class Sampler:
    def __init__(self, volunteer, base):
        """
        :param volunteer: 该采样员搭配的志愿者人数
        :param base: 该采样员的基准效率
        """
        self.volunteer = volunteer
        self.base = base
        self.total = base * 0.8  # 初始时采样员没有搭配志愿者，则效率只有base*0.8

    def __lt__(self, other):
        return getAdd(self) > getAdd(other)  # 基于大顶堆排序，优先级为：增加一名志愿者能提升的效率


# 算法入口
def getResult(arr, x, y):
    """
    :param arr: 各采样员基准效率值（单位人/小时） [60, 600]
    :param x: 采样员人数 [1, 100]
    :param y: 志愿者人数 [1, 500]
    :return: 总最快检测效率（单位人/小时）
    """

    # 优先队列
    pq = queue.PriorityQueue()

    # 将所有采样员员加入优先队列，初始时采样员都不搭配志愿者
    for base in arr:
        pq.put(Sampler(0, base))

    # 只要还有志愿者，就将其分配给采样员
    while y > 0:
        # 如果堆顶采样员已有四个志愿者，那么该采样员能提升的效率为0，说明此时提升0的效率就是所有采样员中能提升的最大效率，即说明所有采样员都安排到了四个采样员，因此再增加志愿者也不会带来效率提升
        if pq.qsize() == 0 or pq.queue[0].volunteer == 4:
            break

        # 如果上一步不成立，则取出堆顶采样员
        s = pq.get()

        # 为其新增一个志愿者，并提升相应效率
        s.total += getAdd(s)
        s.volunteer += 1

        # 重新压入队列
        pq.put(s)
        y -= 1

    ans = 0
    while pq.qsize() > 0:
        ans += pq.get().total

    return int(ans)


# 算法调用
print(getResult(arr, x, y))
