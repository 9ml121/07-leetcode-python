"""
题目解析和算法源码
https://blog.csdn.net/qfc_128220/article/details/128856583

题目描述
当小区通信设备上报警时，系统会自动生成待处理的工单，华为工单调度系统需要根据不同的策略，调度外线工程师（FME）上站修复工单对应的问题。

根据与运营商签订的合同，不同严重程度的工单被处理并修复的时长要求不同，这个要求被修复的时长我们称之为SLA时间。

假设华为和运营商A签订了运维合同，部署了一套调度系统，只有1个外线工程师（FME），每个工单根据问题严重程度会给一个评分，在SLA时间内完成修复的工单，华为获得工单评分对应的积分，超过SLA完成的工单不获得积分，但必须完成该工单。运营商最终会根据积分进行付款。

请设计一种调度策略，根据现状得到调度结果完成所有工单，让这个外线工程师处理的工单获得的总积分最多。

假设从某个调度时刻开始，当前工单数量为N，不会产生新的工单，每个工单处理修复耗时为1小时，请设计你的调度策略，完成业务目标。

不考虑外线工程师在小区之间行驶的耗时。

输入描述
第一行为一个整数N，表示工单的数量。

接下来N行，每行包括两个整数。第一个整数表示工单的SLA时间（小时），第二个数表示该工单的积分。

输出描述
输出一个整数表示可以获得的最大积分。

备注
工单数量N ≤ 10^6
SLA时间 ≤ 7 * 10^5
答案的最大积分不会超过2147483647
用例1
工单编号	SLA	积分
1	1	6
2	7
3	3	2
4	1
5	2	4
6	5
7	6	1

输入
7
1 6
1 7
3 2
3 1
2 4
2 5
6 1

输出
15
说明
最多可获得15积分，其中一个调度结果完成工单顺序为2，6，3，1，7，5，4（可能还有其他顺序）
"""

# todo 贪心思维 + 堆（模拟后悔效果）
import heapq
# 输入
# n表示工单的数量
n = int(input())  
# 第一个整数表示工单的SLA时间（小时），第二个数表示该工单的积分
tasks = [list(map(int, input().split())) for _ in range(n)]

# 输出：一个整数表示可以获得的最大积分
# 1.先将工单按照sla升序排列
tasks.sort(key=lambda x: x[0])

# 2.依次判断是否将工单积分推入堆：
minHeap = [] # 优先级：应该选择的工单积分
cur_time = 0 # 当前时间
for sla, v in tasks:
    if sla > cur_time:
        # 如果当前工单sla大于当前时间，先直接推
        heapq.heappush(minHeap, v)
        cur_time += 1
    else:
        # 否则，判断当前工单积分是否大于堆中积分最小值，如果是，就用当前积分替换堆顶积分
        if v > minHeap[0]:
            heapq.heappop(minHeap)
            heapq.heappush(minHeap, v)

# 3.可以获得的最大积分，就是堆中保存的所有值之和
print(sum(minHeap))
