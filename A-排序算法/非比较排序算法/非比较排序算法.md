# 非比较排序算法

> 参考：
>
> [零起步学算法 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xsgr42/)



<img src="https://pic.leetcode-cn.com/8bf17d84acfe03305f1e6ce5de0041e04940bac7abe06fb3e2abe653dd0a91b8-image.png" alt="image.png" style="zoom:80%;" />



- 「非比较」是指：一个元素在排好序以后的位置，是由它自己的值决定的，，它不需要经过比较。
- 「非比较」排序中蕴含了「哈希表」的思想：由数值映射地址。
- 因此这三种算法一定需要额外的空间才能完成排序任务，时间复杂度可以提升到 *O*(*N*)，但适用场景不多，主要是因为**使用这三种排序一定要保证输入数组的每个元素都在一个合理的范围内**
- 重点需要放在「归并排序」、「快速排序」、「堆排序」





---



# 一 计数排序

![image.png](https://pic.leetcode-cn.com/1646380248-Iqqvyl-image.png)

## 计数排序的基本思想

「计数排序」是这三种排序算法里最好理解的，从名字就可以看出。



**计数排序的基本思想是：**

- 将元素的值，看成计数数组的下标。，然后根据计数从小到大输出得到有序数组。
- 这种做法 **丢失了稳定性**，如果是本题这种基本数据类型的话没有关系。如果是对象类型，就不能这么做了。

**保持稳定性的做法是：**

- 先对计数数组做前缀和，在第二步往回赋值的时候，根据原始输入数组的数据从后向前赋值，前缀和数组保存了每个元素存放的下标信息



## 计数排序的稳定实现
为了维护计数排序的稳定性，除了计数之外，我们还需要做一点工作。以数组：[2, 5, 3, 0, 2, 3, 0, 3] 为例。



1. **第 1 步：得到计数数组，计数数组的元素个数等于原始数组的最大元素 + 1**

| 计数             | 2    | 0    | 2    | 3    | 0    | 1    |
| :--------------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    |





请注意：这里我们就利用了计数排序的基本思想，把数值看成计数数组的下标。

我们看到 3 出现了 3 次。很显然这 3 个 3 一定排在前面 2 个 0 和 2 个 2 的后面，因此我们可以再进一步，计算出前缀和数组。



2. **第 2 步：将计数数组改造成「前缀和」计数数组：**

| 前缀和计数       | 2    | 2    | 4    | 7    | 7    | 8    |
| ---------------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    |



「前缀和」计数数组的意义如下为：排好序以后，最后一个 0 位于数组的第 2 个位置（下标为 1），最后一个 2 位于数组的第 4 个位置（下标为 3），以此类推。



通过「前缀和」计数数组，我们可以很清楚地知道最后一个元素在排好序以后应该位于什么位置，因此我们可以从后向前一次遍历原始数组，把值赋值回去，这样就能保证排序以后数组的稳定性。



3. **第 3 步：从后向前赋值回原始数组。**

最后一个元素是 3，看「前缀和」计数数组，我们知道 3 一定位数原始数组的第 7 位，即下标是 6 的位置。因此在下标 6 位置上先写上 3。同时，「前缀和」计数数组 3 所对应的数值减 1，表示下一个 3 位于排好序以后的第 6 个位置，即下标为 5 的位置



|                  |      |      |      |      |      |      | 3    |      |
| ---------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时「前缀和」计数数组：

| 前缀和计数       | 2    | 2    | 4    | 6    | 7    | 8    |
| ---------------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    |

...



我们再回顾一下计数排序的基本思想：

1. 对于每一个输入数组的元素，计算严格小于它的元素的个数（前缀和计数数组），进而把它放到输出数组对应的位置上。
2. 倒序赋值回去保证了稳定性。希望大家能够想清楚这里使用前缀和计数数组，并且倒序赋值回去的有效性。



如果理解了上面计数排序的算法流程，再看计数排序的适用场景就会比较容易理解。



## 计数排序的适用场景

- 数据的范围小；
- 重复键值多。



例如：年龄、考试成绩等。如果键值有负数和小数的时候怎么办呢？我们可以将参与排序的关键字与非负整数建立一一对应的关系。



说明：计数排序利用了 非负整数 可以作为数组的下标。因此参与排序的元素的值不能太大，否则创建出很大的数组、计算前缀和是浪费资源的。下标是一个非负整数，天然具有顺序性，而通过下标就可以得到每一个数值的个数，通过查询「前缀和」计数数组就能知道它排好序以后所处的位置。



## 代码编写

只考虑待排序数组的值均为非负整数，并且保证排序稳定性的java写法：

```java
public class CountingSort {

    public void sort(int[] nums) {
        int len = nums.length;
        int max = nums[0];
        // 检验数据有效性
        // 找到数组中的最大值，以确定计数数组的长度
        for (int i = 1; i < len; i++) {
            if (nums[i] > max) {
                max = nums[i];
            }
            // 数据有效性校验，因为要将数值作为数组 count 的下标使用，因此 nums[i] 不能小于 0
            if (nums[i] < 0) {
                throw new IllegalArgumentException("该数组不适合使用计数排序");
            }
        }

        // 第 1 步：对原始数组进行计数，这里将原始数组的值，作为了计数数组的下标
        int[] count = new int[max + 1];
        // 遍历原始数组，完成计数
        for (int i = 0; i < len; i++) {
            count[nums[i]] += 1;
        }

        // 第 2 步：将 count 数组改造成前缀和数组，我们需要的是前缀和，在原地进行变换即可
        // 由前缀和数组就可以推出这个元素所在的位置
        for (int i = 1; i <= max; i++) {
            count[i] += count[i - 1];
        }

        // 为了写回去，需要对原始数组做一个拷贝
        int[] numsCopy = new int[len];
        for (int i = 0; i < len; i++) {
            numsCopy[i] = nums[i];
        }
        // 使用 Java 语言可以使用下面这一行代替
        // System.arraycopy(nums, 0, numsCopy, 0, len);

        // 第 3 步：从后向前扫描，依次把看到的数写回原始数组，从后向前是为了保证稳定性
        for (int i = len - 1; i >= 0; i--) {
            // 位置有一个偏移，在纸上写出来就很容易发现规律
            int position = count[numsCopy[i]] - 1;
            // 把看到的数覆盖回去
            nums[position] = numsCopy[i];
            // 前缀和减一，作为下一个看到的相同数存放位置的依据
            count[numsCopy[i]]--;

            // 以上三行，可以用下面这一行代替，但不建议这样写
            // nums[--count[numsCopy[i]]] = numsCopy[i];
        }
    }
}


```

考虑到负数，并且不考虑排序稳定性的python写法：

```python
# 计数排序版本二：考虑到负数的计数排序，并且不考虑稳定性
def countingSort2(nums):
    """
    nums = [-1, 0, 1, -2, 3, -2]
    """
    # 1. 找出最大和最小值,以确定计数数组的长度
    max_val = max(nums)
    min_val = min(nums)

    # 2.初始化计数数组, 并统计每个数字出现的次数
    count = [0] * (max_val - min_val + 1)
    for num in nums:
        count[num - min_val] += 1

    # 4.创建结果数组的起始索引idx，并遍历计数数组
    idx = 0
    for i in range(len(count)):
        for _ in range(count[i]):  # count[i]代表i+min_val的出现次数
            nums[idx] = i + min_val
            idx += 1
```



## 复杂度分析：

- 时间复杂度：O(N+K)，这里 N 是数组的长度，K 是数组的最大值。如果 K 很大，会占用很多空间，在计算前缀和计数数组的时候，复杂度也会增加，此时不适合使用计数排序；
    - 统计数组中数值的范围：O(N)；
    - 计数需要看数组 1 次：O(N)；
    - 计算前缀和计数数组：O(K)；
    - 从后向前赋值需要看数组一次。
- 空间复杂度：O(N+K)，根据代码和时间复杂度的分析不难得到。

## 总结

- 计数排序的适用范围：范围小；重复键值多；可以与非负整数建立一一对应关系。
- 描述「计数排序」算法流程：计算计数数组、将计数数组改造成前缀和数组、从后向前遍历原始数组，依次得到遍历到的数在排好序以后应该在的位置；
- 计数排序是**非原地排序**；
- 计数排序是**稳定排序**。



---

# 二 基数排序

<img src="https://pic.leetcode-cn.com/1646380318-rWFSVn-image.png" alt="image.png" style="zoom:80%;" />



## 基数排序简介
- 基数排序是一种非比较的排序方法，也称为基于关键字的排序
- 例如针对数值排序，个位、十位、百位就是关键字。针对日期数据的排序：年、月、日、时、分、秒就是关键字。
- 为了使得基数排序的描述更为直观，我们也只以非负整数的排序任务为例；
- 在基数排序中认为一个整数的个位、十位分别是一个关键字。
- 重点理解：基数排序的子过程：计数排序（因为要保证稳定性）。

基数排序有两种方式：高位优先（Most significant digital）和低位优先（Least significant digital）。常见的做法是 **低位优先**，对高位优先我们只做简单介绍，重点介绍低位优先。



## 高位优先（不推荐）
### 基数排序（高位优先）的基本思路
高位优先比较直观：先按照高位升序排序，然后按照次高位排序，依次这样进行下去排到最低位。



![image.png](https://pic.leetcode-cn.com/c94b4521e2159d4c6b54a98291e0954ea51ae19b82a33a77c090de0148c5ca42-image.png)





- 该方法的实现使用了「分而治之」的思想递归执行下去，需要借助递归方法实现，且空间复杂度较大。
- 事实上，完全可以先按照低位排序，一直排到最高位。这种做法不仅仅是正确的，实现起来还更简单。



## 低位优先（推荐）

我们通过一个具体的例子，看一下低位优先是如何排序的。例如：`[329, 457, 657, 839, 436, 720, 355]`，使用基数排序的「低位优先」算法执行流程。

![image.png](https://pic.leetcode-cn.com/736cecea3af5ee3ff34d5cef668e35c47c6b9c533120008863bd12176c49c846-image.png)

1. 首先按照个位数字进行一次 **稳定排序**（相同数字顺序不变），得到 [720, 355, 436, 457, 657, 329, 839]；
2. 然后按照十位数字进行一次 **稳定排序**（相同数字顺序不变），得到 [720, 329, 436, 839, 355, 457, 657]；
3. 然后按照百位数字进行一次 **稳定排序**（相同数字顺序不变），得到 [329, 355, 436, 457, 657, 720, 839]。



### 低位优先的有效性
我们比较两个数字的时候，总是先比较最高位。低位优先的基数排序，越高位的排序是放在后面进行的，在高位相同的情况下，需要比较次高位，而次高位在之前的排序中已经排好序。



这其中非常重要的一点是，每一趟基于关键字的排序 **必须使用稳定排序**，请大家在理解了上面的例子以后仔细体会这一点。



### 代码编写
细节：如何得到数位上的数值。

- 先把低位抹去；
- 再取个位（模 10 即可）。

```java
// 计算数位上的数是几，先取个位，再十位、百位
int remainder = (arr[j] / divisor) % 10;
```



**数组中的数都是非负整数的java代码：**

```java
public class RadixSort {

    public void sort(int[] nums) {
        int len = nums.length;
        // 第 1 步：找出最大的数字
        int max = nums[0];
        for (int i = 0; i < len; i++) {
            if (nums[i] > max) {
                max = nums[i];
            }
            // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0
            if (nums[i] < 0) {
                throw new IllegalArgumentException("该数组不适合使用计数排序");
            }
        }

        // 第 2 步：计算出最大的数字有几位，这个数值决定了我们要将整个数组看几遍
        int maxLen = getMaxLen(max);

        // 第 3 步：每一趟都使用计数排序
        int[] count = new int[10];
        int[] temp = new int[len];

        int divisor = 1;
        // 有几位数，外层循环就得执行几次
        for (int i = 0; i < maxLen; i++) {
            // 每一步都使用计数排序，保证排序结果是稳定的，这一步需要额外空间保存结果集，因此把结果保存在 temp 中
            countingSort(nums, temp, divisor, len, count);

            System.arraycopy(temp, 0, nums, 0, len);
            divisor *= 10;
        }
    }

    /**
     *
     * @param nums 原始数组
     * @param temp 在计数排序的过程中使用的辅助数组，这一次基于 divisor 关键字的排序结果存在这里
     * @param divisor
     * @param len 原始数组的长度（冗余变量）
     * @param count 计数数组
     */
    private void countingSort(int[] nums, int[] temp, int divisor, int len, int[] count) {
        // 内层循环得把数组从头到尾看一遍
        for (int j = 0; j < len; j++) {
            // 计算数位上的数是几，先取个位，再十位、百位
            int remainder = (nums[j] / divisor) % 10;
            count[remainder]++;
        }

        for (int j = 1; j < 10; j++) {
            count[j] += count[j - 1];
        }

        for (int j = len - 1; j >= 0; j--) {
            int remainder = (nums[j] / divisor) % 10;
            int index = count[remainder] - 1;
            temp[index] = nums[j];
            count[remainder]--;
        }

        // 重置数组 count，以便下次使用
        for (int j = 0; j < 10; j++) {
            count[j] = 0;
        }
    }

    /**
     * 获取一个整数的最大位数
     *
     * @param num
     * @return
     */
    private int getMaxLen(int num) {
        int maxLen = 0;
        while (num > 0) {
            num /= 10;
            maxLen++;
        }
        return maxLen;
    }
}

```



**基数排序，考虑负数，考虑排序的稳定性的python代码**

```python

class Solution2:
    def sortArray(self, nums: List[int]) -> List[int]:
        return self.radixSort(nums)

    def radixSort(self, nums: list) -> List:
        # 1.找出数组中最大数和最小数
        max_num = float('-inf')
        min_num = float('inf')
        for num in nums:
            max_num = max(max_num, num)
            min_num = min(min_num, num)

        # 2.根据最小数将nums全部转换为非负整数
        for i in range(len(nums)):
            nums[i] += abs(min_num)
        max_num = max_num + abs(min_num)

        # 3.根据最大数的数位进行循环计数排序
        carry = 1
        while (max_num // carry) > 0:
            self.countingSort(nums, carry)
            carry *= 10

        # 4.将nums还原为原本数字
        for i in range(len(nums)):
            nums[i] -= abs(min_num)

        return nums

    # 计数排序
    def countingSort(self, nums, carry):
        # 1.计数数组统计每个数位上的数字出现的次数
        count = [0] * 10
        for num in nums:
            remainder = (num // carry) % 10
            count[remainder] += 1

        # 2.计算每个数字在排序后的数组中的位置(前缀和)
        for i in range(1, 10):
            count[i] += count[i - 1]

        # 3.根据计数数组计算排序后的数组中的位置
        nums_copy = nums.copy()
        for num in reversed(nums_copy):
            remainder = (num // carry) % 10
            # 位置有一个偏移
            idx = count[remainder] - 1
            nums[idx] = num
            count[remainder] -= 1
```





### 复杂度分析：

- 时间复杂度：O(KN)，这里 N 为输入数组的长度，K 为关键字的个数。以非负整数数组的排序任务为例，最大值有几位（K）就需要看数组几遍；
- 空间复杂度：O(N+K)，这里 K（一个数的位数）通常比 N（输入数组的长度）小很多。





---

# 三 桶排序

![image.png](https://pic.leetcode-cn.com/b3efeff54d3dfd06d3394de1f990a733d9a9d1f0f7044d686ce8f1b5aaea2f74-image.png)



## 桶排序的基本思想

**基本思路**：一个坑一个萝卜，也可以一个坑多个萝卜，对每个坑排序，再拿出来，整体就有序。

- 桶排序使用「分而治之」的思想，将待排序数组分配到若干个桶内，然后再对每个桶各自执行一次排序任务。

- 桶内的排序可以使用不同的排序方法，每个桶内排序完成以后，依次将每个桶内的元素取出来，最终得到一个有序数组。

## 通过例子理解桶排序的基本思想

![桶排序.gif](https://pic.leetcode-cn.com/1646380477-CjAsdQ-%E6%A1%B6%E6%8E%92%E5%BA%8F.gif)



- 将要排序的数分到几个大小相同的子区间里，这些子区间称为「桶」；
- 分别对每个桶里的数据进行排序（我们这里使用插入排序）；
- 按照顺序把各个桶中的元素依次取出。

## 桶排序的适用范围

- 数据均匀分布，不会出现很多数落在同一个桶中的情况；
- 如果步长、桶数设置合理，每个桶使用插入排序，即能加快排序，又能保证数据的稳定性。



**参考代码 1**：这里只考虑待排序数组的值均为非负整数的情况。

```java
public class BucketSort {

    public void sort(int[] nums) {
        int len = nums.length;
        int max = nums[0];
        // 第 1 步：找到数组中的最大值，以确定计数数组的长度
        for (int i = 1; i < len; i++) {
            if (nums[i] > max) {
                max = nums[i];
            }
            // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0
            if (nums[i] < 0) {
                throw new IllegalArgumentException("该数组不适合使用计数排序");
            }
        }

        // 第 2 步：计算出最大的数字有几位，这个数值决定了桶的个数
        int maxLen = getMaxLen(max);
        // 步长
        int step = 1000;
        // 决定设置几个桶
        if (maxLen < 5) {
            // 如果最大数小于 10000
            // 3 位数就设置 100 个桶
            // 2 位数就设置 10 个桶
            step = (int) Math.pow(10, maxLen - 1);
        }
        // System.out.println("步长：" + step);

        // 桶的个数
        int bucketLen = max / step + 1;
        // System.out.println("桶的个数：" + bucketLen);

        // 因为不能确定每个桶存放的数据量，因此每个桶的长度都设置为 len
        int[][] temp = new int[bucketLen][len];
        int[] next = new int[bucketLen];

        // 第 3 步：分桶
        for (int i = 0; i < len; i++) {
            // 找到所在的桶的索引
            int bucketIndex = nums[i] / step;
            // 在该桶中放入元素
            temp[bucketIndex][next[bucketIndex]] = nums[i];
            // 该桶存放的元素个数 + 1
            next[bucketIndex]++;
        }

        // 第 4 步：对于每个桶执行插入排序
        for (int i = 0; i < bucketLen; i++) {
            insertionSort(temp[i], next[i] - 1);
        }

        // 第 5 步：从桶里依次取出来
        int index = 0;
        for (int i = 0; i < bucketLen; i++) {
            int curLen = next[i];
            for (int j = 0; j < curLen; j++) {
                nums[index] = temp[i][j];
                index++;
            }
        }
    }

    private void insertionSort(int[] arr, int endIndex) {
        for (int i = 1; i <= endIndex; i++) {
            int temp = arr[i];
            int j = i;
            while (j > 0 && arr[j - 1] > temp) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = temp;
        }

    }

    /**
     * 获取一个整数的最大位数
     *
     * @param num
     * @return
     */
    private int getMaxLen(int num) {
        int maxLen = 0;
        while (num > 0) {
            num /= 10;
            maxLen++;
        }
        return maxLen;
    }
}

```



**参考代码2**: 考虑到非负数



```python
# 桶排序，考虑到负数
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        return self.bucketSort(nums)

    def bucketSort(self, nums):
        # 获取最大值和最小值
        max_val = max(nums)
        min_val = min(nums)
        # 计算桶的数量,这里可以自由确定
        bucket_size = (max_val - min_val) // len(nums) + 1
        # 创建桶
        buckets = [[] for _ in range(bucket_size)]
        # 将元素放入对应的桶中
        for num in nums:
            index = (num - min_val) // len(nums)
            buckets[index].append(num)
        # 对每个桶进行排序
        for bucket in buckets:
            bucket.sort()
        # 合并所有桶的元素
        sorted_nums = []
        for bucket in buckets:
            sorted_nums.extend(bucket)
        return sorted_nums
```



## 复杂度分析

- 时间复杂度：O(N)，
    - 这个复杂度是平均时间复杂度。注意这个结论是线性的，这个结论需要严格证明，不过这个证明过于理论化，有兴趣的朋友可以阅读《算法导论》相关章节的内容。最差时间复杂度是：O(N^2 )，即：全部数据落在一个桶的时候；
    - 由于我们会在桶排序最合适使用的场景下才使用桶排序，因此不考虑最坏时间复杂度。
    - 下面我们给出一个不太严谨的、感性的理解：分桶以后，每个桶使用插入排序的时间复杂度虽为平方级别，如果桶设置合理，桶内的排序可以达到接近线性级别，因此整体时间复杂度为 O(N)。



- 空间复杂度：O(M)，
    - 这里 M 是一个相对笼统的概念，M 需要根据具体实现的细节来定，
    - 如果能够预知每个桶最多能装多少元素，可能这个 M 会很大，如果每个桶设置成为链式结构，M 的值会相对较小一些。

## 稳定性和是否原地排序
桶排序是稳定排序，不是原地排序。这里同样是桶内的排序需要是稳定的排序，整体才会是稳定的。



## 非比较排序的思想

到此为止，三种非比较的排序我们都介绍完了，我们再回顾一下这三类排序的共同特点。

1. 都需要借助额外的空间完成排序，它们都是非原地排序；
2. 它们都有一定的机制保证了排序的稳定性；
3. 三种非比较排序的应用场景有一定局限性，一般来说，要求数据范围不能太大；
4. 非比较的意思是：程序只需要看到这个元素，这个元素的数值就能决定了它所在位置，而不需要通过和其它元素的比较。这样的思想是**「桶」的思想**，这种思想是「哈希表」（散列表）思想的基础。



---



# 四 排序方法总结

|          | 最坏时间复杂度 | 平均时间复杂度                 | 最好时间复杂度 | 额外空间复杂度 | 稳定性 | 是否原地排序 |
| -------- | -------------- | ------------------------------ | -------------- | -------------- | ------ | ------------ |
| 选择排序 | *O*(N^2)       | *O*(N^2)                       | *O*(N^2)       | *O*(1)         | 不稳定 | 原地排序     |
| 冒泡排序 | *O*(N^2)       | *O*(N^2)                       | *O*(*N*)       | *O*(1)         | 稳定   | 原地排序     |
| 插入排序 | *O*(N^2)       | *O*(N^2)                       | *O*(*N*)       | *O*(1)         | 稳定   | 原地排序     |
| 希尔排序 | *O*(N^2)       | *O*(*n*^1.25)∼*O*(1.6*n*^1.25) | (没有相关研究) | *O*(1)         | 不稳定 | 原地排序     |
| 归并排序 | *O*(*N*log*N*) | *O*(*N*log*N*)                 | *O*(*N*log*N*) | *O*(*N*)       | 稳定   | 非原地排序   |
| 快速排序 | *O*(N^2)       | *O*(*N*log*N*)                 | *O*(*N*log*N*) | *O*(log*N*)    | 不稳定 | 原地排序     |
| 计数排序 | *O*(*N*+*K*)   | *O*(*N*+*K*)                   | *O*(*N*+*K*)   | *O*(*N*+*K*)   | 稳定   | 非原地排序   |
| 基数排序 | *O*(*KN*)      | *O*(*KN*)                      | *O*(*N*^2)     | *O*(*K*+*N*)   | 稳定   | 非原地排序   |
| 桶排序   | *O*(N^2)       | *O*(*N*)                       | *O*(*N*)       | 根据情况定     | 稳定   | 非原地排序   |

说明：

- 计数排序中， N 是数组的长度，K 是数组的最大值（假设数组的最小值为 0）；
- 基数排序中， N 是数组的长度，K 是最大值的位数（关键字的个数）。



![image.png](https://pic.leetcode-cn.com/1646380557-zGrAIe-image.png)



十大排序算法里，前七个可以归为一类，它们都是基于比较的排序算法：要排定一个数，一定得看过其它的数以后，才能排定这个数。



而剩下的「计数排序」、「基数排序」、「桶排序」都体现了「桶」的思想。可以认为桶是有序的码放的，我们看到一个数的时候，根据这个数本身的大小，就能知道它应该位于什么位置，它们的时间复杂度虽然相较于前七个要低，但这三个排序算法的使用有局限性：

- 桶排序在数据均匀分布，且范围不能太大的情况下表现良好；

- 计数排序在要求排序关键字少，重复元素多的时候表现良好；

- 基数排序相比较于计数排序而言，减少了桶的个数。

    

> 友情提示：时间复杂度低，并不意味着执行时间较少，时间复杂度只是一个估算，时间复杂度也不是排序算法的唯一指标。



1. 在基于比较的排序方法里，选择排序、冒泡排序、插入排序都是线性的算法，都得通过一个一个比较完成，因此需要两层循环，它们的时间复杂度为 O(N^2)，空间复杂度为 O(1)。
2. 而归并排序借助了额外的空间和递归调用栈使得靠后的较小元素一下子来到了数组靠前的位置；
3. 快速排序借助 partition 过程和递归调用栈使得每一次 partition 需要比较的元素个数越来越小。



「归并排序」和「快速排序」使用「分治思想」通过「递归」实现，使得平均复杂度可以达到 O(NlogN)，这其中也体现了「空间换时间」的思想。



## 原地排序和非原地排序的区别

原地排序和非原地排序是排序算法的两种不同实现方式。

1. 原地排序（In-place Sorting）是指在排序过程中不需要额外的辅助空间，只利用原有的输入数组进行排序。
    - 原地排序算法对于空间复杂度要求较高，适用于内存有限的情况。
2.  非原地排序（Out-of-place Sorting）是指在排序过程中需要额外的辅助空间来存储中间结果或者排序后的结果。
    - 非原地排序算法相对于原地排序算法来说，对于空间复杂度要求较低，但可能需要更多的额外空间。



- 基于比较的排序算法，除了归并排序，都是原地排序。
- 但是原地排序不等于空间复杂度为 O(1)，特殊的例子是快速排序，它需要的空间是递归栈，用户保存递归的过程中的临时信息。

- 桶排序、计数排序、基数排序基于桶的思想，都是非原地排序。



在实际应用中，我们需要根据具体的场景和需求选择合适的排序算法。

- 原地排序算法可以节省空间，但可能需要更多的时间来移动和交换元素；
- 非原地排序算法可以提高排序的效率，但需要额外的空间来存储中间结果。



## 额外空间复杂度
- 基于比较的排序算法，除了归并排序和快速排序，它们都仅仅只是借助了交换时候需要的 1 个辅助空间，因此空间复杂度是 O(1)。

- 归并排序在归并的时候，需要借助和原始数组同等大小的空间。并且归并排序和快速排序都用到了「栈」作为辅助的数据结构。



## 排序算法的稳定性
如果实现上一不小心，有可能会把本来可以实现成稳定排序的算法给实现成不稳定的。在插入排序和归并排序的介绍中，我们都强调过这个细节。



基于比较的排序算法，只要是线性的，一个一个比较过去的，都是稳定的排序算法，我们回想一下插入排序、冒泡。而归并借助了辅助空间以后，仍然可以做到稳定。



而选择排序、堆排序、希尔排序、快速排序元素的交换具有跳跃性，显然不是稳定排序。快速排序因为不具有稳定性，因此对象类型的排序算法一般使用归并排序或者是归并排序的变种。



三个基于桶思想的排序算法都是稳定的排序算法，要特别注意这些算法是如何保证稳定性。



**另外，只要指定好比较规则，即使是非稳定的排序算法也可以把它变成稳定的排序算法，这一过程叫做稳定化。**



## 排序算法对数据的理解能力
1. **选择排序**是一个不太灵活的排序方法，每一轮看完不能为下一轮提供有用的信息，而插入排序、**冒泡排序**可以提前检测到数组是否有序，以加快排序速度。选择排序并非一无是处，它的优点是交换的次数最少，如果交换的成本比较大，适合使用选择排序。

2. **插入排序**在数组越有序的时候排序越快，这里有序指的是升序，如果数组是接近降序的话，插入排序会很慢。
3. **快速排序**在数组越有序的时候排序越慢，因为越有序不管是升序还是降序，递归树的深度都增加，我们可以采用随机化切分元素的办法使得最差时间复杂度出现的概率大大降低。**快速排序**还特别适用于有大量重复值的元素的排序。

4. **堆排序**是选择排序的优化，希尔排序是插入排序的优化。归并排序和快速排序都有各自的优化技巧，当处理的元素个数较少的时候，可以在**归并排序**和**快速排序**的子过程里使用插入排序。



