"""
题目解析和算法源码
https://blog.csdn.net/qfc_128220/article/details/134867943?spm=1001.2014.3001.5501

题目描述
小扇和小船今天又玩起来了数字游戏，

小船给小扇一个正整数 n（1 ≤ n ≤ 1e9），小扇需要找到一个比 n 大的数字 m，使得 m 和 n 对应的二进制中 1 的个数要相同，如：

4对应二进制100

8对应二进制1000

其中1的个数都为1个

现在求 m 的最小值。

输入描述
输入一个正整数 n（1 ≤ n ≤ 1e9）

输出描述
输出一个正整数 m

用例1
输入
2
输出
4
说明
2的二进制10，

4的二进制位100，

1的个数相同，且4是满足条件的最小数

用例2
输入
7
输出
11
说明
7的二进制111，

11的二进制位1011，

1的个数相同，且11是满足条件的最小数
"""


# 1. 获取输入
# 要找二进制中1个数相同，且比n大的最小整数
n = int(input())  # n>=1

# 2.算法 101=>110  111=>0111=>1011  1100=>01100=>10100=>10001
bin_s = list(bin(n)[2:])
bin_s.insert(0, '0')
# print(bin_s)

# 倒序遍历bin_s, 并统计当前遍历位置后面有多少个0
cnt_0 = 0
sz = len(bin_s)
for i in range(sz-1, -1, -1):
    # 1. 统计当前位置后面有多少个0
    if bin_s[i] == '0':
        # 2. 如果0后面是1，交换2个位置数字，并将后面位置的所有0都调到前面
        if i+1 < sz and bin_s[i+1] == '1':
            bin_s[i], bin_s[i+1] = bin_s[i+1], bin_s[i]
            for j in range(i+2, sz):
                if cnt_0 > 0:
                    bin_s[j] = '0'
                    cnt_0 -= 1
                else:
                    bin_s[j] = '1'
            break
        cnt_0 += 1


s = ''.join(bin_s)
# print(s)
print(int(s, 2))

# 28 ==> 35
# print(bin(35)[2:])
