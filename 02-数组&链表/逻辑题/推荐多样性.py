"""
题目解析和算法源码
https://blog.csdn.net/qfc_128220/article/details/135004447?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22135004447%22%2C%22source%22%3A%22qfc_128220%22%7D

题目描述
推荐多样性需要从多个列表中选择元素，一次性要返回 N 屏数据（窗口数量），每屏展示 K 个元素（窗口大小），选择策略：

各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推

每个列表的元素尽量均分为 N 份，如果不够 N 个，也要全部分配完，参考样例图：

（1）从第一个列表中选择 4 条 0 1 2 3，分别放到 4 个窗口中

（2）从第二个列表中选择 4 条 10 11 12 13，分别放到 4 个窗口中

（3）从第三个列表中选择 4 条 20 21 22 23，分别放到 4 个窗口中

（4）再从第一个列表中选择 4 条 4 5 6 7，分别放到 4 个窗口中

...

（5）再从第一个列表中选择，由于数量不足 4 条，取剩下的 2 条，放到 窗口1 和 窗口2

（6）再从第二个列表中选择，由于数量不足 4 条并且总的元素数达到窗口要求，取 18 19 放到 窗口3 和 窗口4

image

输入描述
第一行输入为 N，表示需要输出的窗口数量，取值范围 [1, 10]

第二行输入为 K，表示每个窗口需要的元素数量，取值范围 [1, 100]

之后的行数不定（行数取值范围 [1, 10]），表示每个列表输出的元素列表。元素之间以空格隔开，已经过排序处理，每个列表输出的元素数量取值范围 [1, 100]

输出描述
输出元素列表，元素数量 = 窗口数量 * 窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例：

先输出窗口1的元素列表，再输出窗口2的元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表

备注
每个列表会保证元素数量满足窗口要求，不需要考虑元素不足情况
每个列表的元素已去重，不需要考虑元素重复情况
每个列表的元素列表均不为空，不需要考虑列表为空的情况
每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序
每个列表的元素数量可能是不同的
用例1
输入
4
7
0 1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18 19
20 21 22 23 24 25 26 27 28 29
输出
0 10 20 4 14 24 8 1 11 21 5 15 25 9 2 12 22 6 16 26 18 3 13 23 7 17 27 19
"""



# 获取输入
# 需要输出的窗口数量cols
n = int(input())
# 每个窗口需要的元素数量rows
k = int(input())
# 输入的元素列表
grid = []
# todo 注意：以下处理连续输入在本地会有问题，在oj系统是可以的
# 牛客系统应该是会在输入完测试数据后，自动强行终止程序调用
# while True:
#     try:
#         grid.append(list(map(int, input().split())))
#     except:
#         break

# 本地调试写法
while True:
    s = input()
    # 判定空行为输入截止条件
    if s == '':
        break
    else:
        grid.append(list(map(int, s.split())))


# 算法
def main():
    # 初始化输出屏幕
    # 每个列表会保证元素数量满足窗口要求，不需要考虑元素不足情况
    # 每个列表的元素数量可能是不同的
    windows = [[-1] * n for _ in range(k)]

    # 记录输入行坐标
    x = 0

    # 遍历输出行坐标
    for i in range(k):
        # 当前轮次是否发生了"借"动作
        is_borrow = False
        for j in range(n):
            windows[i][j] = grid[x].pop(0)
            if len(grid[x]) == 0 and len(grid) > 1:
                # 当前输入行grid[x]长度小于n, 并且至少有2行，就需要向输入列表下一行借数字
                is_borrow = True
                grid.pop(x)
                if x == len(grid):
                    x = 0
        if not is_borrow:
            x = (x+1) % len(grid)
    ans = []
    # 输出结果要向纵向遍历，再横向遍历
    for j in range(n):
        for i in range(k):
            ans.append(windows[i][j])

    return ' '.join(map(str, ans))


print(main())

"""
测试用例
5
8
0 1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18
19 20 21
22 23 24
25 26 27 28 29
30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55
"""