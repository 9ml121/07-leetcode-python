"""
题目解析和算法源码
https://blog.csdn.net/qfc_128220/article/details/130766999

题目描述
张兵和王武是五子棋迷，工作之余经常切磋棋艺。这不，这会儿又下起来了。走了一会儿，轮张兵了，对着一条线思考起来了，这条线上的棋子分布如下: 用数组表示: -1 0 1 1 1 0 1 0 1 -1 棋了分布说明:

-1代表白子，0代表空位，1 代表黑子
数组长度L，满足 1 < L < 40，L为奇数
你得帮他写一个程序，算出最有利的出子位置。 最有利定义：

找到一个空位(0)，用棋子(1/-1)填充该位置，可以使得当前子的最大连续长度变大
如果存在多个位置，返回最靠近中间的较小的那个坐
如果不存在可行位置，直接返回-1
连续长度不能超过5个(五字棋约束)
输入描述
第一行: 当前出子颜色

第二行: 当前的棋局状态

输出描述
1个整数，表示出子位置的数组下标

用例1
输入
1
-1 0 1 1 1 0 1 -1 1
输出
5
说明
当前为黑子 (1)，放置在下标为5的位置，黑子的最大连续长度，可以由3到5

用例2
输入
-1
-1 0 1 1 1 0 1 0 1 -1 1
输出
1
说明
当前为白子，唯一可以放置的位置下标为1，白子的最大长度，由1变为2

用例3
输入
1
0 0 0 0 1 0 0 0 0 1 0
输出
5
说明
可行的位置很多，5最接近中间的位置坐标
"""


# todo 考察左右双指针（中心扩散）
# 类似：A-滑动窗口&双指针\双指针\左右指针\845. 数组中的最长山脉.py

# 输入
# 第一行: 当前出子颜色, 1或者-1
color = int(input())
# 第二行: 当前的棋局状态，数组长度n为奇数， -1代表白子，0代表空位，1 代表黑子
nums = list(map(int, input().split()))
# print(nums) # [-1, 0, 1, 1, 1, 0, 1, -1, 1]


# 输出：算出最有利的出子位置,可以使得当前子的最大连续长度变大
def main():
    # 1.先统计当前子的最大连续长度max_sz
    n = len(nums)
    max_sz = 0
    l = 0
    while r < n:
        if nums[r] == color:
            l = r
            while r + 1 < n and nums[r+1] == color:
                r += 1
            max_sz = max(max_sz, r-l+1)
        else:
            r += 1
            
    # 连续长度不能超过5个(五字棋约束)
    if max_sz >= 5:
        return -1

    ans = -1 # 出子位置，初始化为一个不存在的下标
    # 2.每遇到一个0，就尝试下子，然后判断当前颜色最长连续长度是否>=最大长度max_sz,并且不大于5
    # 题目说明n为奇数,中间位置只有一个
    mid = n//2
    for i in range(n):
        num = nums[i]
        if num == 0:
            l, r = i, i
            while l-1 >= 0 and nums[l-1] == color:
                l -= 1
            while r + 1 < n and nums[r+1] == color:
                r += 1
            cur_sz = r - l + 1

            # 使得当前子的最大连续长度变大
            if cur_sz <= 5 and cur_sz > max_sz:
                max_sz = cur_sz
                ans = i
            # 如果存在多个位置，返回最靠近中间的较小的那个坐
            elif cur_sz == max_sz and ans >= 0 and abs(mid-i) < abs(mid-ans):
                ans = i

    return ans


print(main())
