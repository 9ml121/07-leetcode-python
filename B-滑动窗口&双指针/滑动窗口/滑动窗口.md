# 滑动窗口

> 参考：[算法吧 | 快来算法吧 (suanfa8.com)](https://suanfa8.com/sliding-window)
>
> [我写了首诗，把滑动窗口算法变成了默写题 | labuladong 的算法小抄](https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--f02cd/)



## 滑动窗口是什么

![img](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/suanfa8/96ab04ea-834d-4d82-bba3-e502e069d9cd.jpg)

解决这一类问题的特点是：

- 用于解决在 **数组** 上的问题；
- 使用两个变量，称为左指针、右指针（或者快指针、慢指针）；
- 右指针先向右移动、左指针再向右边移动，**交替进行**；
- 直到右指针移动到数组的末尾。

下面的动画展示了这样的过程，它像极了一个窗口在数组上滑动，因此称为「滑动窗口」。

![img](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/suanfa8/cd6b0d8f-7dea-4068-8945-93a90711a181.gif)

## 理解「滑动窗口」需要先理解「暴力解法」

下面这 2 道问题是使用「滑动窗口」解决的基本问题，它们非常重要。

- 「力扣」第 3 题：无重复字符的最长子串（中等）
- 「力扣」第 209 题：长度最小的子数组（中等）

掌握这些问题的方式就是先思考暴力解法，然后再思考如何优化。



「滑动窗口」问题是典型的应用「循环不变量」解决的问题，比较考验我们编码和调试的能力。



滑动窗口与双指针是基于暴力解法的优化，少考虑很多暴力解法要考虑的子问题，将时间复杂度降到线性。解题时需要考虑的细节较多，定义好「循环不变量」是关键。

- 思想简单，但是代码比较难一次写对；
- 滑动窗口的思想是：**先向右移动右指针、再向右移动左指针**，这样左右指针交替执行（ **不回头** ），可以完成一些问题；
- 滑动窗口是 **暴力解法的优化** ，如何 **根据目标函数把暴力解法的一系列解排除掉，是使用滑动窗口的前提** ，一定要分析清楚；
- 下面提供的是一种参考的写法，请**不要照搬**，应该 **先理解滑动窗口的思想（暴力解法的剪枝）** ，然后多加练习，掌握编写代码的技巧和细节。



滑动窗口的参考写法（不是模板，**请不要原样照搬**，仅供参考，理解算法设计思想是更重要的）：



```java
// 模板 1
public class Solution {

    public String minWindow(String s, String t) {
        // 同方向移动，起始的时候，都位于 0，表示我们定义搜索区间为 [left, right) ，此时区间为空区间
        int left = 0;
        int right = 0;

        while (right < sLen) {

            if ( 在右移的过程中检测是否满足条件 ) {
                // 对状态做修改，好让程序在后面检测到满足条件
            }

            // 右边界右移 1 格
            right++;

            while ( 满足条件 ) {

                // ① 走到这里是满足条件的，左边界逐渐逐渐左移，可以取最小值

                if ( 在左移的过程中检测是否不满足条件 ) {
                    // 对状态做修改，好让程序在后面检测到不满足条件
                }

                // 左边界左移 1 格
                left++;
            }
            // ② 走到这里是不满足条件的，右边界逐渐右移，可以取最大值
        }
        return 需要的结果变量;
    }
}

```

说明：什么是条件？

- 条件就是在遍历的过程中，我们需要时刻关注的一些变量的值。
- 对于第 3 题：虽然题目要我们求的是滑动窗口内 不重复 的子串的最大值，但我们更关注的是滑动窗口有重复的子串的时候，
- 因此条件就是：滑动窗口 [left, right) 有重复。在 ② 处取最大值。

```java
// 模板 2
int left = 0, right = 0;

while (right < s.size()) {
    // 增大窗口
    window.add(s[right]);
    right++;
    
    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}

```



```c++
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}


```







## Leetcode3：无重复字符的最长子串

「力扣」第 3 题：

> 这道题给我们一个字符串，要求我们找出这个字符串中不含有重复字符的 **最长子串** 的长度。



首先我们需要弄清楚一个概念：「子串」，它通常区别于「子序列」。它们的区别是：

- 子串（substring）：在原始数组中一定连续；

- 子序列（subsequeue）：在原始数组中不一定连续，只需要这些子序列中的元素保持在原始数组中的相对顺序。



**分析思路**

1. 一开始的时候，`left` 与 `right` 重合，`left` 不动，`right` 尝试向右边扩张，直到 `[left, right]` 中有恰有 1 个重复元素；
2. 如果在子区间 `[left, right]` 中有重复元素，`[left, right + 1]`、`[left, right + 2]` 一直到 `[left, len - 1]` 一定包含重复元素，这一点是这问题可以使用「滑动窗口」的原因。此时就得考虑 left 向右移动，这是因为：
   - left 不能向左移动：因为向左移动，仍然不能改变 [left, right] 中有恰有 1 个重复元素的现状；
   - left 只能向右移动，直到 left 刚刚好越过 right 指向的那个重复的元素为止。
3. 接着有没有必要继续移动 left 呢？
   - 答案是不可以，因为我们要求的是最长的子串的长度，此时的子串只是局部最长的。
   - 我们应该移动 `right` 以期待获得更长的不重复子串；
4. 这样的过程一直进行下去，直到 `right` 到达字符串的末尾。



**下面我们分析这个过程为什么比暴力枚举要快。**

- 当我们得到了一个有重复元素的子串的时候，和它 有相同前缀的所有子串 都会一下子被排除；
- 在判断子区间 `[left, right]` 是否有重复字符的时候，我们不必每一次都做扫描。
- - 事实上，我们只需要开辟一个字符频数数组，让右边界进来的时候，字符频数加 1，此时检测是否有重复。
  - 当左边界滑出的时候，字符频数减 1，此时检测是否无重复；
- 有重复字符的时候，尝试让左边界 left 右移，尝试让区间内无重复字符。没有重复字符的时候，尝试右边界 right 右移，以尝试让区间长度更长。





以上就是解决这道问题的基本思路。

这种 `right` 主动向右移动，`left` 被动向右移动的方式就是滑动窗口的思想，也叫「尺取法」或者「虫取法」。

这个名字可以说是非常形象了，一个资深的裁缝为我们量体裁衣，他很可能就是用右手大拇指在你的肩膀上做「滑动窗口」的样子。



下面我们来看一下代码是如何编写的：



**说明：**

- 编写代码的过程中遵守的 **循环不变量** 是：`[left, right)` 内不包含重复字符。
- 注意，这个区间是左闭右开的，好处是滑动窗口长度 = `right - left`。
- 在一开始的时候，`right` 之前的元素已知，在本轮循环中，希望把 `right` 纳入，保持区间内无重复字符这一性质。



```python
class Solution2:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 返回无重复字符的最长子串长度

        ans = 0  # 记录结果
        # 循环不变量：nums[left..right) 不包含重复字符
        # 注意，这个区间是左闭右开的，好处是滑动窗口长度 = `right - left`
        # 这里窗口用的字典，也可以用字符频数数组，将字符的 ACSII 码作为数组的下标
        window = {}
        left = 0
        for right in range(len(s)):
            right_char = s[right]
            # window记录窗口中已经使用的字符的数量，
            window[right_char] = window.get(right_char, 0) + 1
            # 寻找窗口中的重复字符
            while window[right_char] == 2:
                # 如果已经出现过，窗口左边界应该移动到上一次相同字符的下一个位置，并且window要减去移除窗口的字符个数
                left_char = s[left]
                window[left_char] -= 1
                left += 1
            # 最后记录结果，此时窗口一定是没有重复元素的
            ans = max(ans, right - left + 1)
        return ans


```



**复杂度分析：**

- 时间复杂度：O(N)，这里 N 是输入字符的长度，left 和 right 各扫过数组一次；

- 空间复杂度：O(M)，这里 M 表示字符出现的种类数。



**说明：**

- 创建**字符频数数组**，将字符的 ACSII 码作为数组的下标；
- 右边指针移动的过程中做**加法**：只要字符频数数组超过 1，刚刚好等于 2 的时候，就说明子区间内有重复元素；
- 左边指针移动的过程中做**减法**：因为我们的算法在子区间刚刚好有 1 个重复字符的时候，就想方设法让子区间没内有重复元素，因此重复元素的个数有且仅有 
  1 个，字符频数数组内单个字符的个数最多为 2，当左边界指向字符刚刚好减到 1 的时候，就说明子区间内没有重复元素（这样的说法有点绕，希望大家能够通过具体的例子，自己在纸上写写画画想明白）；
- 在右边指针移动的过程中记录最大值。
  - 要特别注意这里记录最大值的位置，不能在 `if (freq[charArray[right]] == 2) {` 之前，
  - 因为此时滑动窗口内可能有重复元素，因此，只能在 `if (freq[charArray[right]] == 2) {` 之后。






### **滑动窗口的优化**
仔细思考我们就会发现：一步一步来到重复元素出现过的地方太慢了，我们是不是可以一下子来到重复元素的后面呢？



答案是：完全可以。



具体的做法是：

1. 在遍历的过程中，不是记录元素的频数（其实在上一种做法里，频次最多也只用到 2），而是记录元素出现的位置。

2. 当有重复元素出现的时候，只要这个元素之前出现的下标 大于等于 当前滑动窗口左边界的下标，就可以直接跳过来；
3. 如果重复元素之前出现的下标严格小于当前滑动窗口左边界的下标，左边界不用移动。
4. 这两种情况，都需要更新当前看到的字符的下标为最新看到的字符的下标。



参考代码 2：

Python 代码：滑动窗口的优化。

```python
class Solutio3:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 重复元素上一次出现的位置很重要
        ans = 0
        window = {}
        left = 0
        # [left, right) 没有重复元素
        for right in range(len(s)):
            elem = s[right]
            if elem in window:
                # 优化点：
                # 1.当有重复元素出现的时候，只要这个元素之前出现的下标 大于等于 当前滑动窗口左边界的下标，就可以直接跳过来；
                # 2.如果重复元素之前出现的下标严格小于当前滑动窗口左边界的下标，左边界不用移动。
                left = max(left, window[elem] + 1)

            # 3.window记录看到的每个元素在数组中的 最新 下标
            window[elem] = right
            ans = max(ans, right - left + 1)
        return ans
```



事实上，对于建立字符和某个数值的映射，也可以使用 **哈希表** 做。相信大家不难体会它们二者的差别。





## Leetcode76：最小覆盖子串

「力扣」第 76 题：

> ```
> 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
> 
> 注意：
> 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
> 如果 s 中存在这样的子串，我们保证它是唯一的答案。
> ```

### 滑动窗口的思想：
1. 用`i`,`j`表示滑动窗口的左边界和右边界，通过改变i,j来扩展和收缩滑动窗口，可以想象成一个窗口在字符串上游走，
2. 当这个窗口包含的元素满足条件，即包含字符串T的所有元素，
3. 记录下这个滑动窗口的长度`j-i+1`，这些长度中的最小值就是要求的结果。



> **「滑动窗口」有如下的特点**：
>
> - right 先向右移动，移到不能再移动的时候，left 再向右移动；
> - right 变长刚好满足条件，left 变短到刚好不满足条件，然后 right 变长刚好满足条件，如此循环下去，直到 right 到达末尾。



### 步骤：

1. 步骤一

    - 不断增加j使滑动窗口增大，直到窗口包含了T的所有元素

2. 步骤二

    - 不断增加i使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，

    - 这个时候不能再扔了，再扔就不满足条件了，记录此时滑动窗口的长度，并保存最小值

3. 步骤三
    - 让i再增加一个位置，这个时候滑动窗口肯定不满足条件了，
    - 那么继续从步骤一开始执行，寻找新的满足条件的滑动窗口，如此反复，直到j超出了字符串S范围。

### 难点：

**如何判断滑动窗口包含了T的所有元素？**



1. 我们用一个字典`need`来表示当前滑动窗口中需要的各元素的数量，一开始滑动窗口为空，用T中各元素来初始化这个need，
2. 当滑动窗口扩展或者收缩的时候，去维护这个need字典；
    - 例如当滑动窗口包含某个元素，我们就让need中这个元素的数量减1，代表所需元素减少了1个；
    - 当滑动窗口移除某个元素，就让need中这个元素的数量加1。 
    - 记住一点：need始终记录着当前滑动窗口下，我们还需要的元素数量，我们在改变i,j时，需同步维护need。 
    - 值得注意的是，只要某个元素包含在滑动窗口中，我们就会在need中存储这个元素的数量，
    - 如果某个元素存储的是负数代表这个元素是多余的。比如当need等于{'A':-2,'C':1}时，表示当前滑动窗口中，我们有2个A是多余的，同时还需要1个C。
    - 这么做的目的就是为了步骤二中，排除不必要的元素，数量为负的就是不必要的元素，而数量为0表示刚刚好。 

回到问题中来，那么如何判断滑动窗口包含了T的所有元素？



3. 结论就是当need中所有元素的数量都小于等于0时，表示当前滑动窗口不再需要任何元素。

### 优化:



如果每次判断滑动窗口是否包含了T的所有元素，都去遍历need看是否所有元素数量都小于等于0，这个会耗费O(k)的时间复杂度，k代表字典长度，



最坏情况下，k可能等于len(S)。 其实这个是可以避免的，



我们可以维护一个额外的变量`needCnt`来记录所需元素的总数量，

- 当我们碰到一个所需元素c，不仅need[c]的数量减少1，同时needCnt也要减少1，这样我们通过needCnt就可以知道是否满足条件，而无需遍历字典了。 
- 前面也提到过，need记录了遍历到的所有元素，而只有need[c]>0大于0时，代表c就是所需元素



### 这里还要注意一些细节：



-  同时记录最小子串长度`min_len`和起始位置`start`。
-   min_len，一开始要设置一个不可能的值；

### 时间复杂度：



我们会用j扫描一遍S，也会用i扫描一遍S，最多扫描2次S，所以时间复杂度是O(n)，空间复杂度为O(k)，k为S和T中的字符集合。

```python
# 循环不变量是：[left-1..right]窗口里的元素是涵盖 t 所有字符的子串
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        # 记录t中每个字符的出现次数
        need = {}
        for ch in t:
            need[ch] = need.get(ch, 0) + 1
        # 记录t中不同字符的总数，
        # 注意：这里也可以换为len(p),但是后面needCnt -= 1判断条件是need[right_char]>=0
        needCnt = len(need)

        # 初始化左右指针和结果变量
        left = 0
        start = 0
        min_len = len(s) + 1
        # 遍历右指针
        for right, right_char in enumerate(s):
            # 如果右指针的字符在t中出现过，更新need中对应字符的出现次数
            if right_char in need:
                need[right_char] -= 1
                # 如果该字符的出现次数减为0，说明已经找到了一个需要的字符，更新needCnt
                if need[right_char] == 0:
                    needCnt -= 1

            # 当找到了所有需要的字符时，开始移动左指针
            while needCnt == 0:
                # 更新最小子串长度和起始位置
                if right - left + 1 < min_len:
                    min_len = right - left + 1
                    start = left
                # 如果左指针的字符在t中出现过，更新need中对应字符的出现次数
                left_char = s[left]
                if left_char in need:
                    need[left_char] += 1
                    # 如果该字符的出现次数增加为1，说明需要的字符不再全部被包含在子串中，更新needCnt，并打破循环
                    if need[left_char] > 0:
                        needCnt += 1
                # 移动左指针
                left += 1

        # 如果结果变量始终未被更新，说明不存在满足条件的子串
        return s[start:start + min_len] if min_len < len(s) + 1 else ""
```



## Leetcode438. 找到字符串中所有字母异位词

>给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>
>**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```python
# 第二版：优化==>循环不变量是[left-1..right]窗口里的元素是涵盖 p 所有字符的子串
class Solution3:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        # 初始化需要的字符及其数量
        need = {}
        for c in p:
            need[c] = need.get(c, 0) + 1
        # 注意：这里也可以换为len(need),但是后面needCnt -= 1的判断条件是need[right_char]==0
        needCnt = len(p)
        ans = []
        left = 0
        # 扩大右窗口，直到窗口里面包含了 p的所有字符
        for right in range(len(s)):
            # 如果右指针指向的字符在需要的字符中
            right_char = s[right]
            if right_char in need:
                # 将该字符的数量减1
                need[right_char] -= 1
                # 如果该字符的数量不小于0，则需要匹配的字符数量减1
                if need[right_char] >= 0:
                    needCnt -= 1
            # 当找到了所有需要的字符时，开始移动左指针
            while needCnt == 0:
                # 如果需要匹配的字符数量为0，并且长度正好跟 p相等，则将左指针加入结果列表
                if right - left + 1 == len(p):
                    ans.append(left)
                # 如果左指针的字符在p中出现过，更新need中对应字符的出现次数
                left_char = s[left]
                if left_char in need:
                    need[left_char] += 1
                    # 如果该字符的出现次数增加为1，说明需要的字符不再全部被包含在子串中，更新needCnt，并打破循环
                    if need[left_char] > 0:
                        needCnt += 1
                left += 1
        return ans
```

