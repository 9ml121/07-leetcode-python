"""
图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。

每个单元格的  平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。

如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。



给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。

 

示例 1:
输入:img = [[1,1,1],[1,0,1],[1,1,1]]
输出:[[0, 0, 0],[0, 0, 0], [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0


示例 2:
输入: img = [[100,200,100],[200,50,200],[100,200,100]]
输出: [[137,141,137],[141,138,141],[137,141,137]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
 

提示:

m == img.length
n == img[i].length
1 <= m, n <= 200
0 <= img[i][j] <= 255
"""
from typing import List

# todo 二维矩阵前缀和
# 类似：B-滑动窗口&双指针\差分数列&前缀和\304. 二维区域和检索 - 矩阵不可变.py


# 方法1：简单思路就是统计以每个点 (i, j) 为中心的周围八个点的数值和，然后计算平均数更新答 案 ans
class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        # 计算矩阵img每个单元格周边9个元素平均值
        offsets = [(0, -1), (0, 1), (-1, -1), (-1, 0),
                   (-1, 1), (1, -1), (1, 0), (1, 1)]
        m = len(img)
        n = len(img[0])
        ans = [[0] * n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                s = img[i][j]
                c = 1
                for ox, oy in offsets:
                    nx = i + ox
                    ny = j + oy
                    if 0 <= nx < m and 0 <= ny < n:
                        s += img[nx][ny]
                        c += 1

                ans[i][j] = s//c

        return ans

# 方法2：二维数组前缀和
# 只不过题目明确了 是周围八个点的和，因此节省的时间也是常数，复杂度不变。

class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        # 计算矩阵img每个单元格周边9个元素平均值
        m, n = len(img), len(img[0])
        # 建立前缀和
        pre = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        
        for i in range(1, m+1):
            for j in range(1, n + 1):
                # todo 矩阵原点到当前位置的累加和 = 当前位置左边的累加和 + 上边的累加和 + 当前位置元素 - 左上角累加和
                pre[i][j] = pre[i-1][j] + pre[i][j-1] + \
                    img[i-1][j-1] - pre[i-1][j-1]
        
        # 使用，等价于以(x1,y1)为矩阵左上角，以(x2,y2)为矩阵右下角的所有格子的和
        ans = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(m):
            for j in range(n):
                x1 = max(0, i-1)
                y1 = max(0, j-1)
                x2 = min(m-1, i+1)
                y2 = min(n-1, j+1)
                cnt = (y2 - y1 + 1) * (x2 - x1 + 1)
                ans[i][j] = (pre[x2+1][y2+1] + pre[x1][y1] -
                             pre[x1][y2+1] - pre[x2+1][y1])//cnt
        return ans
