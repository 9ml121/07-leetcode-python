"""
题目描述
公司创新实验室正在研究如何最小化资源成本，最大化资源利用率，请你设计算法帮他们解决一个任务混部问题：
有taskNum项任务，每个任务有开始时间（startTime），结束时间（endTime），并行度（parallelism）三个属性，
并行度是指这个任务运行时将会占用的服务器数量，一个服务器在每个时刻可以被任意任务使用但最多被一个任务占用，任务运行完成立即释放（结束时刻不占用）。
任务混部问题是指给定一批任务，让这批任务由同一批服务器承载运行，
请你计算完成这批任务混部最少需要多少服务器，从而最大化控制资源成本。

输入描述
第一行输入为taskNum，表示有taskNum项任务
接下来taskNum行，每行三个整数，表示每个任务的
开始时间（startTime ），结束时间（endTime ），并行度（parallelism）

输出描述
一个整数，表示最少需要的服务器数量

备注
1 <= taskNum <= 100000
0 <= startTime < endTime <= 50000
1 <= parallelism <= 100
用例
输入	    3
        2 3 1
        6 9 2
        0 5 1
输出	2
说明
一共有三个任务，

第一个任务在时间区间[2, 3]运行，占用1个服务器，
第二个任务在时间区间[6, 9]运行，占用2个服务器，
第三个任务在时间区间[0, 5]运行，占用1个服务器，
需要最多服务器的时间区间为[2, 3]和[6, 9]，需要2个服务器。

输入	    2
        3 9 2
        4 7 3
输出	5
说明
一共两个任务，

第一个任务在时间区间[3, 9]运行，占用2个服务器，
第二个任务在时间区间[4, 7]运行，占用3个服务器，
需要最多服务器的时间区间为[4, 7]，需要5个服务器。
"""

'''
差分数组问题:
1. 有taskNum项任务，每个任务有开始时间（startTime），结束时间（endTime），并行度（parallelism）三个属性，
- 并行度p其实就代表在开始时间st和结束时间et之间,这个任务要增加的服务器数量inc
- 结束时刻立即释放,不占用,证明左闭右开[i, j)

2. 问题:taskNum项任务运行期间, 最少需要多少服务器?
就是找原始数组所有区间需要增加服务器的最大值

3. 原始数组nums初始值应该为0,后续根据差分数组diffs进行更新, 长度是多少呢?
0 <= startTime < endTime <= 50000
1 <= taskNum <= 100000
一种方法是构建一个50001长度的原始数组nums,这样就包含了所有开始时间和结束时间位置
另外一种是查找taskNum项任务当中,st和et不重复的个数作为nums的长度
'''
# 1.获取输入
# n = int(input())
# n = 4
# tasks = []
# for i in range(n):
#     task = list(map(int, input().split()))
#     tasks.append(task)
# tasks.sort(key=lambda x: x[0])
# print(tasks)

# 0。测试
n = 3
tasks = [[2, 3, 1], [6, 9, 2], [0, 5, 1]]
# tasks = [[0, 5, 1], [2, 3, 1], [6, 9, 2]]
# tasks = [[1, 5, 1], [3, 9, 1], [7, 10, 1]]
# tasks = [[0, 5, 1], [2, 3, 1], [2, 8, 1], [3, 9, 1]]


# 2. 主要算法
# 构建原始数组
times = [0] * 50001

# 构建差分数组
diffs = [0] * 50001

# 根据每个任务在开始时间和结束时间期间需要增加的服务器,更新diffs
for st, et, p in tasks:
    diffs[st] += p
    diffs[et] -= p  # 结束时间不占用

# 根据差分数组更新原始数组
times[0] = diffs[0]
for i in range(1, len(times)):
    times[i] = times[i-1] + diffs[i]

print(max(times))

