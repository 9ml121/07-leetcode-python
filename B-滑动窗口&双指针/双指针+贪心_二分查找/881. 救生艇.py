""" 
给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。

每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。

返回 承载所有人所需的最小船数 。

 

示例 1：
输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)

示例 2：
输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)

示例 3：
输入：people = [3,5,3,4], limit = 5
输出：4
解释：4 艘船分别载 (3), (3), (4), (5)
 

提示：
1 <= people.length <= 5 * 104
1 <= people[i] <= limit <= 3 * 104
"""
from typing import List



"""
方法一：贪心
要使需要的船数尽可能地少，应当使载两人的船尽可能地多。

设 people 的长度为 n。考虑体重最轻的人：
1.若他不能与体重最重的人同乘一艘船，那么体重最重的人无法与任何人同乘一艘船，此时应单独分配一艘船给体重最重的人。
  从 people 中去掉体重最重的人后，我们缩小了问题的规模，变成求解剩余 n−1 个人所需的最小船数，将其加一即为原问题的答案。

2.若他能与体重最重的人同乘一艘船，那么他能与其余任何人同乘一艘船，为了尽可能地利用船的承载重量，选择与体重最重的人同乘一艘船是最优的。
  从 people 中去掉体重最轻和体重最重的人后，我们缩小了问题的规模，变成求解剩余 n−2 个人所需的最小船数，将其加一即为原问题的答案。
"""

# todo 排序 + 贪心 + 左右双指针
# 类似：A-滑动窗口&双指针\双指针+其他算法\租车骑绿岛.py
class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        # 每艘船最多载两人，重量之和不超过limit，返回 承载所有人所需的最小船数
        # 预排序
        people.sort()
        n = len(people)
        ans = 0
        
        l, r = 0, n-1
        while l <= r:
            # 1.载2人(最重的+最轻的<=limit)
            if l < r and people[l] + people[r] <= limit:
                l += 1
                r -= 1
            else:
                # 2.载1人(最重的>limit)
                r -= 1
            ans += 1

        return ans
